<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='现代CPU的发展史 现代 CPU 技术发展 介绍 这篇文章主要是介绍CPU技术的发展，包括最近几十年CPU性能提升和半导体工艺发展，当前技术发展方向。希望'>
<title>现代CPU的发展史</title>

<link rel='canonical' href='/p/test-chinese/'>

<link rel="stylesheet" href="/scss/style.min.24ef1cc321916467896e8c70c10c0ad7b98c2a8df14298032fb637216e397f50.css"><meta property='og:title' content='现代CPU的发展史'>
<meta property='og:description' content='现代CPU的发展史 现代 CPU 技术发展 介绍 这篇文章主要是介绍CPU技术的发展，包括最近几十年CPU性能提升和半导体工艺发展，当前技术发展方向。希望'>
<meta property='og:url' content='/p/test-chinese/'>
<meta property='og:site_name' content='笼中雀'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2024-02-07T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2024-02-07T00:00:00&#43;00:00'/><meta property='og:image' content='https://hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222093836.png' />
<meta name="twitter:title" content="现代CPU的发展史">
<meta name="twitter:description" content="现代CPU的发展史 现代 CPU 技术发展 介绍 这篇文章主要是介绍CPU技术的发展，包括最近几十年CPU性能提升和半导体工艺发展，当前技术发展方向。希望"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222093836.png' />
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    <img src="https://obsidian-hjz.oss-cn-beijing.aliyuncs.com/bijierhao/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231027090119.jpg" width="300" height="300" class="site-logo" loading="lazy" alt="Avatar">
                
                </a>
                
                    <span class="emoji">🍥</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">笼中雀</a></h1>
            <h2 class="site-description">欲买桂花同载酒，     终不似、少年游。</h2>
        </div>
    </header><ol class="social-menu">
            
                <li>
                    <a 
                        href='https://github.com/CaiJimmy/hugo-theme-stack'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://twitter.com'
                        target="_blank"
                        title="Twitter"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c-.002 -.249 1.51 -2.772 1.818 -4.013z" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E9%93%BE%E6%8E%A5/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>链接</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>档案</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        

        <div class="menu-bottom-section">
                <li id="i18n-switch">  
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M4 5h7" />
  <path d="M9 3v2c0 4.418 -2.239 8 -5 8" />
  <path d="M5 9c-.003 2.144 2.952 3.908 6.7 4" />
  <path d="M12 20l4 -9l4 9" />
  <path d="M19.1 18h-6.2" />
</svg>



                    <select name="language" onchange="window.location.href = this.selectedOptions[0].value">
                        
                            <option value="/" selected>中文</option>
                        
                            <option value="/en/" >English</option>
                        
                    </select>
                </li>
            
            
            
                <li id="dark-mode-toggle">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                    <span>暗色模式</span>
                </li>
            
        </div>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li>
      <ol>
        <li><a href="#cpu-指令集和运行原理"><strong><code>CPU 指令集和运行原理</code></strong></a></li>
        <li><a href="#cpu-性能提升和未来方向"><strong><code>CPU 性能提升和未来方向</code></strong></a></li>
        <li><a href="#cpu-技术方向对软件开发技术的影响"><strong><code>CPU 技术方向对软件开发技术的影响</code></strong></a></li>
      </ol>
    </li>
  </ol>

  <ol>
    <li><a href="#计算机结构"><strong><code>计算机结构</code></strong></a></li>
    <li><a href="#cpu-结构"><strong><code>CPU 结构</code></strong></a>
      <ol>
        <li><a href="#高速缓存"><strong>高速缓存</strong></a></li>
        <li><a href="#控制单元"><strong>控制单元</strong></a></li>
        <li><a href="#运算单元"><strong>运算单元</strong></a></li>
        <li><a href="#寄存器"><strong>寄存器</strong></a></li>
      </ol>
    </li>
  </ol>

  <ol>
    <li><a href="#指令集"><strong><code>指令集</code></strong></a>
      <ol>
        <li><a href="#x86"><strong><code>x86</code></strong></a></li>
        <li><a href="#x86-指令集发展"><strong>x86 指令集发展</strong></a></li>
        <li><a href="#arm"><strong><code>ARM</code></strong></a></li>
        <li><a href="#arm-指令集发展"><strong>ARM 指令集发展</strong></a></li>
        <li><a href="#risc-v"><strong><code>RISC-V</code></strong></a></li>
        <li><a href="#risc-v-指令集"><strong>RISC-V 指令集</strong></a></li>
        <li><a href="#risc-v-寄存器"><strong>RISC-V 寄存器</strong></a></li>
      </ol>
    </li>
    <li><a href="#指令编码格式"><strong><code>指令编码格式</code></strong></a></li>
    <li><a href="#指令集对比"><strong><code>指令集对比</code></strong></a>
      <ol>
        <li><a href="#复杂指令集和精简指令集"><strong><code>复杂指令集和精简指令集</code></strong></a></li>
        <li><a href="#指令集架构实现对比"><strong>指令集架构实现对比</strong></a></li>
      </ol>
    </li>
    <li><a href="#其他"><strong><code>其他</code></strong></a>
      <ol>
        <li><a href="#cpu-遇到不支持的指令如何处理"><strong><code>CPU 遇到不支持的指令如何处理</code></strong></a></li>
        <li><a href="#x86-和-arm-的性能"><strong><code>x86 和 ARM 的性能</code></strong></a></li>
      </ol>
    </li>
    <li><a href="#小结"><strong><code>小结</code></strong></a></li>
  </ol>

  <ol>
    <li><a href="#功耗时钟频率性能"><strong><code>功耗、时钟频率、性能</code></strong></a></li>
    <li><a href="#功耗墙"><strong><code>功耗墙</code></strong></a></li>
    <li><a href="#小结-1"><strong><code>小结</code></strong></a></li>
  </ol>

  <ol>
    <li><a href="#流水线介绍"><strong><code>流水线介绍</code></strong></a></li>
    <li><a href="#现代流水线设计"><strong><code>现代流水线设计</code></strong></a>
      <ol>
        <li><a href="#读取指令"><strong><code>读取指令</code></strong></a></li>
        <li><a href="#多指令读取"><strong><code>多指令读取</code></strong></a></li>
        <li><a href="#分支预测"><strong><code>分支预测</code></strong></a></li>
        <li><a href="#l1-指令缓存"><strong><code>L1 指令缓存</code></strong></a></li>
        <li><a href="#tlb-缓存"><strong><code>TLB 缓存</code></strong></a></li>
        <li><a href="#解码指令"><strong><code>解码指令</code></strong></a></li>
        <li><a href="#预解码"><strong><code>预解码</code></strong></a></li>
        <li><a href="#多解码器"><strong><code>多解码器</code></strong></a></li>
        <li><a href="#微指令缓存"><strong><code>微指令缓存</code></strong></a></li>
        <li><a href="#发射指令"><strong><code>发射指令</code></strong></a></li>
        <li><a href="#多发射"><strong><code>多发射</code></strong></a></li>
        <li><a href="#动态调度"><strong><code>动态调度</code></strong></a></li>
        <li><a href="#执行指令"><strong><code>执行指令</code></strong></a></li>
        <li><a href="#多执行"><strong><code>多执行</code></strong></a></li>
        <li><a href="#计算单元缓冲区"><strong><code>计算单元缓冲区</code></strong></a></li>
        <li><a href="#增加计算单元"><strong><code>增加计算单元</code></strong></a></li>
        <li><a href="#l1l2-数据缓存"><strong><code>L1/L2 数据缓存</code></strong></a></li>
      </ol>
    </li>
    <li><a href="#主流-cpu-核心的微架构设计"><strong>主流 CPU 核心的微架构设计</strong></a>
      <ol>
        <li><a href="#intel"><strong>Intel</strong></a></li>
        <li><a href="#apple"><strong>Apple</strong></a></li>
        <li><a href="#arm-1"><strong>ARM</strong></a></li>
      </ol>
    </li>
    <li><a href="#小结-2"><strong><code>小结</code></strong></a></li>
  </ol>

  <ol>
    <li><a href="#simd"><strong><code>SIMD</code></strong></a></li>
    <li><a href="#gpu"><strong><code>GPU</code></strong></a></li>
    <li><a href="#小结-3"><strong><code>小结</code></strong></a></li>
  </ol>

  <ol>
    <li><a href="#超线程"><strong><code>超线程</code></strong></a></li>
    <li><a href="#多核心"><strong><code>多核心</code></strong></a>
      <ol>
        <li><a href="#大小核"><strong><code>大小核</code></strong></a></li>
      </ol>
    </li>
    <li><a href="#小结-4"><strong><code>小结</code></strong></a></li>
  </ol>

  <ol>
    <li><a href="#引入高速缓存"><strong><code>引入高速缓存</code></strong></a>
      <ol>
        <li><a href="#内存读写过程"><strong>内存读写过程</strong></a></li>
        <li><a href="#缓存提升方向"><strong><code>缓存提升方向</code></strong></a></li>
      </ol>
    </li>
    <li><a href="#内存性能提升"><strong><code>内存性能提升</code></strong></a>
      <ol>
        <li><a href="#更多内存类型"><strong><code>更多内存类型</code></strong></a></li>
        <li><a href="#集成封装工艺提升"><strong><code>集成封装工艺提升</code></strong></a></li>
      </ol>
    </li>
    <li><a href="#小结-5"><strong><code>小结</code></strong></a></li>
  </ol>

  <ol>
    <li><a href="#soc"><strong><code>SOC</code></strong></a>
      <ol>
        <li><a href="#soc-组成结构"><strong><code>SOC 组成结构</code></strong></a></li>
      </ol>
    </li>
    <li><a href="#dsa"><strong><code>DSA</code></strong></a>
      <ol>
        <li><a href="#dsa-设计"><strong><code>DSA 设计</code></strong></a></li>
      </ol>
    </li>
    <li><a href="#chiplet"><strong><code>Chiplet</code></strong></a></li>
    <li><a href="#小结-6"><strong><code>小结</code></strong></a></li>
  </ol>

  <ol>
    <li><a href="#intel-处理器发展"><strong><code>Intel 处理器发展</code></strong></a></li>
  </ol>

  <ol>
    <li><a href="#更多核心数"><strong><code>更多核心数</code></strong></a></li>
    <li><a href="#simddsa单元"><strong><code>SIMD、DSA单元</code></strong></a></li>
    <li><a href="#硬件性能提升放缓"><strong><code>硬件性能提升放缓</code></strong></a></li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/p/test-chinese/">
                
                    <img src="https://hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222093836.png" loading="lazy" alt="Featured image of post 现代CPU的发展史" />
                
            </a>
        </div>
    

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/cpu/" >
                CPU
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/test-chinese/">现代CPU的发展史</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Feb 07, 2024</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 43 分钟
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="现代cpu的发展史">现代CPU的发展史</h1>
<h1 id="现代-cpu-技术发展httpswwwcnblogscomjcloudp17918297html"><strong><a class="link" href="https://www.cnblogs.com/Jcloud/p/17918297.html"  target="_blank" rel="noopener"
    >现代 CPU 技术发展</a></strong></h1>
<h1 id="介绍"><strong><code>介绍</code></strong></h1>
<p>这篇文章主要是介绍<code>CPU</code>技术的发展，包括最近几十年<code>CPU</code>性能提升和半导体工艺发展，当前技术发展方向。希望可以帮助软件开发者理解<code>CPU</code>指令集和组成运行原理、<code>CPU</code>性能提升的现状和瓶颈、<code>CPU</code>技术发展方向会如何影响<code>软件开发/设计</code>的框架和编程思想。</p>
<blockquote>
<p>提示：因为是面向软件开发者，所以会忽略掉一些电路设计、制造工艺等底层的硬件知识。同时也不会特别深入的介绍每个知识点，只是提供一个概览。</p>
</blockquote>
<h3 id="cpu-指令集和运行原理"><strong><code>CPU 指令集和运行原理</code></strong></h3>
<p>当前使用最广泛的指令集是<code>x86</code>、<code>ARM</code>、<code>RISC-V</code>，指令集对于<code>CPU</code>性能和<code>软件开发</code>有多大的影响，指令集的发展方向是什么。现代<code>CPU</code>内部微架构、流水线是如何设计的，为什么<code>CPU</code>的控制单元和缓存相比<code>GPU</code>复杂很多。</p>
<h3 id="cpu-性能提升和未来方向"><strong><code>CPU 性能提升和未来方向</code></strong></h3>
<p>近些年<code>CPU</code>性能提升遇到了<code>功耗墙</code>的问题导致提升速度放缓，为什么以前的优化技术都遇到了瓶颈，同时当前有哪些新的技术方向用于提高<code>CPU</code>的性能。</p>
<h3 id="cpu-技术方向对软件开发技术的影响"><strong><code>CPU 技术方向对软件开发技术的影响</code></strong></h3>
<p>软件最终会在<code>CPU</code>上运行，更好的利用<code>CPU</code>提供的能力进行编程才能带来更好的性能。一部分<code>CPU</code>优化技术是内部微架构调整对软件开发者是透明的，例如<code>时钟频率</code>和<code>IPC</code>的提升。但是另一些优化技术需要软件开发者进行优化，例如<code>多核心</code>、<code>SIMD</code>、<code>DSA</code>等。这些需要软件开发者改造的技术会如何影响编程语言和系统框架的设计，从而影响软件开发者的编程方式。</p>
<h1 id="cpu-结构和原理"><strong><code>CPU 结构和原理</code></strong></h1>
<h2 id="计算机结构"><strong><code>计算机结构</code></strong></h2>
<p><img src="/https:/hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222093756.png"
	
	
	
	loading="lazy"
	
		alt="https://hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222093756.png"
	
	
></p>
<p>1945 年<code>冯诺依曼</code>提出了一种计算机实现的结构设计，现代的计算机和<code>CPU</code>基本上依然是基于冯诺依曼结构的思想进行实现。冯诺依曼结构定义了计算机的<code>5</code>个组成部分，分别是<code>内存</code>、<code>控制单元</code>、<code>运算单元</code>、<code>输入</code>、<code>输出</code>：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>模块</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>内存</td>
<td>内存是一个存储器。操作指令和数据以二进制的形式存储在内存中。</td>
</tr>
<tr>
<td>控制单元</td>
<td>控制单元是一个协调者。控制单元按照程序指令顺序从内存中读取指令进行执行，将指令发送到运算单元进行计算。同时控制单元也会协调内存和输入/输出设备之间的数据传输。</td>
</tr>
<tr>
<td>运算单元</td>
<td>计算单元包含加减乘除等计算器。运算单元根据控制单元发送的指令，从内存中读取数据进行计算，计算完成后重新写回到内存中。</td>
</tr>
<tr>
<td>输入/输出</td>
<td>输入/输出设备主要是外部的一些设备进行数据交换。输入设备将数据和指令输入到计算机中，常见的输入设备有键盘、鼠标。计算机处理后将数据输出到外部设备中，常见的输出设备有显示器。</td>
</tr>
</tbody>
</table></div>
<blockquote>
<p>提示：还有一种不同的架构是哈佛架构，它是一种程序指令和数据分开的计算机结构。现在L1缓存中就是使用哈佛架构的思想将指令和数据缓存分开存储。</p>
</blockquote>
<h2 id="cpu-结构"><strong><code>CPU 结构</code></strong></h2>
<p><img src="/https:/hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222093836.png"
	
	
	
	loading="lazy"
	
		alt="https://hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222093836.png"
	
	
></p>
<p>现代<code>CPU</code>虽然使用<code>冯诺依曼架构</code>思想进行设计，但是经过几十年技术的发展非常复杂。因为<code>内存</code>不属于<code>CPU</code>内部结构，现代<code>CPU</code>主要分为<code>4</code>个组成部分，分别是<code>高速缓存</code>、<code>控制单元</code>、<code>运算单元</code>、<code>寄存器</code>。这里先简单介绍一下各个组成部分的功能，后面<code>流水线实现</code>的部分会更详细的介绍。</p>
<h3 id="高速缓存"><strong>高速缓存</strong></h3>
<p><code>高速缓存</code>将内存中更频繁使用的<code>程序指令</code>和<code>数据</code>保存在<code>高速缓存</code>中，避免每次都从内存读取降低数据读写延迟。</p>
<ul>
<li><code>多级缓存</code>现代<code>CPU</code>通常有<code>2-3</code>级缓存，离CPU更近的缓存速度更快但是容量更低。</li>
</ul>
<h3 id="控制单元"><strong>控制单元</strong></h3>
<p>控制单元是<code>CPU</code>中最复杂的部分，负责调度和协调其他部分进行运行。调度流水线执行、异常处理等。</p>
<ul>
<li><code>流水线调度</code>分支预测、高速缓存读写、指令读取、指令解码、指令调度执行、乱序执行、指令发射、更新寄存器</li>
<li><code>异常处理</code>处理 CPU 运行时的各种异常</li>
</ul>
<h3 id="运算单元"><strong>运算单元</strong></h3>
<p>运算单元包含大量的运算器执行计算任务，包括逻辑运算、分支、内存读写单元。</p>
<ul>
<li><code>ALU</code>算数逻辑单元负责整数加减乘除和位运算</li>
<li><code>FPU</code>浮点单元负责浮点数运算</li>
<li><code>Branch</code>分支单元用于分支判断，当 CPU 支持分支预测时还需要更新分支预测缓存和分支预测错误回滚执行</li>
<li><code>SIMD</code>向量单元负责向量运算</li>
<li><code>内存读写</code>内存单元负责内存读写，从缓存中读取数据或将数据写回缓存</li>
</ul>
<h3 id="寄存器"><strong>寄存器</strong></h3>
<p>寄存器用于保持运行时的临时数据和<code>CPU</code>自身的一些状态值。</p>
<ul>
<li><code>通用寄存器</code>用于存储临时数据，局部变量/函数参数/返回值等数据</li>
<li><code>PC</code>程序计数器存储下一条指令的地址</li>
<li><code>IP</code>指令指针用于存储当前执行的指令地址</li>
<li><code>SP</code>堆栈指针用于存储栈的地址</li>
</ul>
<h1 id="指令集架构"><strong><code>指令集架构</code></strong></h1>
<p><code>ISA</code>（指令集架构）是一种处理器基本功能和指令集架构规范。它定义了<code>CPU</code>硬件可以执行的所有操作指令，指令的编解码格式、指令类型、寄存器、内存寻址、异常处理、权限级别等内容。<code>编译器</code>和<code>CPU</code>选择一种指令集规范作为标准进行实现，这样可以保证任意符合<code>指令集</code>规范编译的代码都可以相同<code>指令集</code>规范的CPU上正常运行。<code>ISA</code>主要有<code>指令集</code>、<code>寄存器</code>、<code>内存模型</code>、<code>异常中断处理</code>等规范定义。</p>
<p><code>指令集架构规范组成</code></p>
<ul>
<li><code>指令集</code>支持的操作指令、指令的编解码格式、指令长度</li>
<li><code>寄存器</code>支持的寄存器类型、寄存器数量</li>
<li><code>内存模型</code>支持的内存访问方式、内存寻址方式、内存一致性规则</li>
<li><code>异常/中断处理</code>定义了处理器如何处理异常和终端事件</li>
</ul>
<h2 id="指令集"><strong><code>指令集</code></strong></h2>
<p>指令集定义了处理器可以执行的所有操作指令和指令的编解码格式。目前常见的指令集主要分为两种类型，<code>复杂指令集</code>和<code>精简指令集</code>。复杂指令集<code>CISC</code>主要是以<code>x86</code>为代表，精简指令集<code>RISC</code>主要是以<code>ARM</code>/<code>RISC-V</code>为代表。</p>
<h3 id="x86"><strong><code>x86</code></strong></h3>
<p><code>x86</code>指令集架构最早使用在<code>Intel</code>在<code>1978</code>年推出<code>8086</code>处理器，指令集专利由<code>Intel</code>和<code>AMD</code>拥有。目前主要是在<code>PC</code>/<code>笔记本</code>和<code>服务器</code>市场使用，<code>x86</code>的优势在于<code>软件生态/兼容性</code>和<code>高性能</code>，劣势在<code>高能耗</code>和<code>开放性</code>：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>特点</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>软件生态</td>
<td>发展时间最久技术最成熟，积累了大量的技术和软件。一直很注重兼容性帮助它占有了更多的市场份额，但是兼容性也限制了技术升级和大量的历史包袱需要兼容增加了复杂性</td>
</tr>
<tr>
<td>性能高</td>
<td>高性能场景占有大部分的份额</td>
</tr>
<tr>
<td>能耗高</td>
<td>同样性能下x86相比RISC指令集需要更多的能耗，限制了在低功耗设备上使用</td>
</tr>
<tr>
<td>开放性低</td>
<td>专利主要由Intel所有，其它厂商授权使用</td>
</tr>
<tr>
<td>芯片厂商</td>
<td>Intel、AMD</td>
</tr>
<tr>
<td>主要领域</td>
<td>80%+ PC/笔记本、90%服务器市场</td>
</tr>
</tbody>
</table></div>
<h3 id="x86-指令集发展"><strong>x86 指令集发展</strong></h3>
<p><code>x86</code>包含多个扩展指令集，指令长度至少<code>8</code>位可变长度。以下是<code>x86</code>指令集的一些重要版本更新：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>特性</th>
<th>年份</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>16 位</td>
<td>1978</td>
<td>Intel 在 1978 年推出16位指令集使用在8086处理器</td>
</tr>
<tr>
<td>32 位</td>
<td>1985</td>
<td>Intel 公司推出了 x86 指令集的32位扩展，可支持 32 位软件运行</td>
</tr>
<tr>
<td>64 位</td>
<td>2003</td>
<td>AMD 公司推出了 x86 指令集的64位扩展，可支持 64 位软件运行</td>
</tr>
<tr>
<td>SSE</td>
<td>1999</td>
<td>Intel 推出了 第一代 SIMD 指令集扩展SSE，可支持固定 128 位数据的向量计算</td>
</tr>
<tr>
<td>AVX</td>
<td>2011</td>
<td>Intel 推出了 第二代 SIMD 指令集扩展AVX，可以支持 256-512 位数据的向量计算</td>
</tr>
<tr>
<td>x86s</td>
<td>2023</td>
<td>Intel 推出的纯 64 位架构的白皮书，希望可以减少对于 16、32 位的支持降低兼容性包袱</td>
</tr>
</tbody>
</table></div>
<h3 id="arm"><strong><code>ARM</code></strong></h3>
<p><code>ARM</code>指令集架构是英国 ARM 公司开发的一种<code>RISC</code>指令集架构，指令集专利由<code>ARM</code>公司拥有。<code>ARM</code>诞生于<code>1980</code>年代，当时的处理器都是基于<code>CISC</code>设计复杂度高、功耗大，<code>ARM</code>公司希望使用精简的指令集实现低功耗和高性能，可以应用在嵌入式设备和移动设备中。</p>
<p>因为<code>ARM</code>有非常好的<code>能效</code>优势，目前主要是使用在追求功耗比的<code>嵌入式</code>和<code>移动设备</code>。<code>ARM</code>设备几乎占据所有的<code>手机</code>和<code>Pad</code>市场。在<code>笔记本</code>市场因为苹果切换到<code>ARM</code>，同时<code>高通</code>和<code>INVIDIA</code>开始布局<code>ARM</code>桌面端芯片未来也会推动<code>ARM</code>份额的提升，目前已经占据了<code>15%+</code>的笔记本市场份额。近年<code>ARM</code>性能和芯片设计水平逐渐提高，<code>ARM</code>在<code>服务器</code>市场的份额逐渐提升。</p>
<p>不过<code>ARM</code>也有和<code>x86</code>同样的问题就是开放性，导致<code>ARM</code>受到了<code>RISC-V</code>的挑战。<code>ARM</code>指令集专利属于<code>ARM</code>公司，同时<code>ARM</code>公司对使用指令集会有一些限制。</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>特点</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>软件生态</td>
<td>手机/Pad移动设备和 Mac 系统比较完善，但是Windows平台还是会有兼容性问题使用率很低</td>
</tr>
<tr>
<td>性能高</td>
<td>峰值性能相比x86竞品性能略低，不过近年也在高速发展</td>
</tr>
<tr>
<td>能耗低</td>
<td>因为ARM追求低功耗比的设计，同时大量低功耗设备厂商的硬/软件优化，能耗比一直领先</td>
</tr>
<tr>
<td>开放性中</td>
<td>专利由ARM所有。虽然比x86开放性会好一些，但也导致部分厂商开始尝试完全开源的RISC-V。同时由于RISC-V的竞争，ARM也适当放宽了对于自定义指令集的限制</td>
</tr>
<tr>
<td>芯片厂商</td>
<td>Apple、高通、华为、联发科</td>
</tr>
<tr>
<td>主要领域</td>
<td>几乎所有移动设备、14%笔记本市场、7%服务器市场、嵌入式</td>
</tr>
</tbody>
</table></div>
<h3 id="arm-指令集发展"><strong>ARM 指令集发展</strong></h3>
<p><img src="/https:/hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222093939.png"
	
	
	
	loading="lazy"
	
		alt="https://hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222093939.png"
	
	
></p>
<p><code>ARM</code>包含多个扩展指令集，指令长度为固定<code>32</code>位。以下是<code>ARM</code>的一些重要版本更新：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>指令集</th>
<th>版本</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>32 位</td>
<td>Armv1</td>
<td>1985 年 ARM 推出了32位架构的指令集</td>
</tr>
<tr>
<td>NEON</td>
<td>Armv7</td>
<td>2004 年 ARM 推出了第一代 SIMD 指令集扩展NEON，可支持固定 128 位数据的向量计算</td>
</tr>
<tr>
<td>硬件虚拟化</td>
<td>Armv7</td>
<td>可支持在同一台物理机上运行多个虚拟机的硬件虚拟化扩展</td>
</tr>
<tr>
<td>64 位</td>
<td>Armv8</td>
<td>2011 年推出了64位扩展，可支持 64 位软件运行，有31个 64 位通用寄存器</td>
</tr>
<tr>
<td>SSE</td>
<td>Armv8.2</td>
<td>2014 年 ARM 推出了第二代 SIMD 指令集扩展SSE，可支持可变长度 128-2048 位数据的向量计算</td>
</tr>
</tbody>
</table></div>
<h3 id="risc-v"><strong><code>RISC-V</code></strong></h3>
<p><code>RISC-V</code>架构是<code>2010</code>年由加州大学伯克利分校发起的开源<code>RISC</code>指令集架构标准。<code>RISC-V</code>有以下几个优势：</p>
<ul>
<li><code>精简设计</code>设计非常简单，相比<code>x86</code>和<code>ARM</code>指令集设计更加精简，降低了复杂度和指令数量。</li>
<li><code>模块化设计</code>采用模块化设计思想。提供精简的基础指令集实现基础能力，其它包括<code>浮点</code>、<code>SIMD</code>、<code>原子操作</code>、<code>位运算</code>等指令都是通过扩展指令集提供。芯片设计厂商可以基于自身需求将各种指令集扩展模块进行组合应用到不同的场景。</li>
<li><code>开源``x86</code>/<code>ARM</code>都需要授权才能使用，<code>RISC-V</code>完全开源可以免费使用不用担心版权和专利费的问题。</li>
</ul>
<p><code>RISC-V</code>的优势在于<code>更先进</code>的设计和<code>开源</code>，劣势在<code>软件生态</code>和芯片厂商的<code>设计能力</code>还需要进步：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>特点</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>软件生态</td>
<td>比较弱。目前更多是用在一些嵌入式设备或协处理器中，操作系统、软件开发、用户级软件还在起步阶段</td>
</tr>
<tr>
<td>性能中</td>
<td>峰值性能相比x86/ARM性能差一些，更多是因为x86/ARM芯片厂商的技术更成熟</td>
</tr>
<tr>
<td>能耗中</td>
<td>和ARM差不多，更多是因为ARM芯片厂商的技术更成熟</td>
</tr>
<tr>
<td>开放性高</td>
<td>由于开源吸引了大量芯片设计厂商的加入，支持添加自定义指令集，不过也导致了一些生态兼容性问题</td>
</tr>
<tr>
<td>芯片厂商</td>
<td>主要是新型芯片设计商，所以设计能力上相比差一些</td>
</tr>
<tr>
<td>主要领域</td>
<td>1%处理器市场、嵌入式、协处理器（手机上目前已经有不少使用RISC-V指令集设计的协处理器）</td>
</tr>
</tbody>
</table></div>
<h3 id="risc-v-指令集"><strong>RISC-V 指令集</strong></h3>
<p><code>RISC-V</code>有3个<code>基础指令集</code>和多个扩展指令集，指令长度为固定<code>32</code>位。以下是<code>RISI-V</code>常见的指令集：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>指令集</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>RV32I</td>
<td>基础指令集</td>
<td>32位整数指令集，包含 32 个 32 位的通用寄存器</td>
</tr>
<tr>
<td>RV32E</td>
<td>基础指令集</td>
<td>低功耗嵌入式32位整数指令集，包含 16 个 32 位的通用寄存器</td>
</tr>
<tr>
<td>RV64I</td>
<td>基础指令集</td>
<td>64位整数指令集，包含 32 个 64 位的通用寄存器</td>
</tr>
<tr>
<td>F/D/Q</td>
<td>浮点扩展指令集</td>
<td>单精度 32 位、双精度 64 位、四倍精度 128 位</td>
</tr>
<tr>
<td>M</td>
<td>整数扩展指令集</td>
<td>整数乘法除法指令集</td>
</tr>
<tr>
<td>A</td>
<td>原子操作扩展指令集</td>
<td>原子操作指令集</td>
</tr>
<tr>
<td>B</td>
<td>位操作扩展指令集</td>
<td>位操作指令集</td>
</tr>
<tr>
<td>P</td>
<td>SIMD 扩展指令集</td>
<td>固定长度的SIMD 运算</td>
</tr>
<tr>
<td>V</td>
<td>向量运算扩展指令集</td>
<td>可变长度的向量运算</td>
</tr>
<tr>
<td>C</td>
<td>压缩指令扩展指令集</td>
<td>可将指令长度压缩位 16 位用于低功耗场景</td>
</tr>
</tbody>
</table></div>
<h3 id="risc-v-寄存器"><strong>RISC-V 寄存器</strong></h3>
<p><img src="/https:/hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094023.png"
	
	
	
	loading="lazy"
	
		alt="https://hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094023.png"
	
	
></p>
<p><strong><strong>RISC-V 汇编语言</strong></strong></p>
<p><img src="/https:/hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094042.png"
	
	
	
	loading="lazy"
	
		alt="https://hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094042.png"
	
	
></p>
<p><img src="/https:/hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094055.png"
	
	
	
	loading="lazy"
	
		alt="https://hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094055.png"
	
	
></p>
<p><img src="/https:/hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094106.png"
	
	
	
	loading="lazy"
	
		alt="https://hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094106.png"
	
	
></p>
<h2 id="指令编码格式"><strong><code>指令编码格式</code></strong></h2>
<p>指令集规范定义了指令的二进制格式。以<code>ARM</code>指令集为例，编译器在编译时按照指令集规范将每一个汇编指令<code>编码</code>成<code>32</code>位的二进制指令，<code>CPU</code>在运行时通过解码器按照指令集规范将二进制指令<code>解码</code>成特定的指令进行执行。</p>
<p><code>x86</code>指令集更复杂，<code>ARM</code>和<code>RISC-V</code>更精简。<code>x86</code>使用可变长度指令，至少<code>8</code>位+，同时<code>x86</code>支持更多的内存寻址模式。<code>ARM</code>使用固定<code>32</code>位指令，至少少数几种内存寻址模式。</p>
<p>ARM指令编码格式</p>
<p><img src="/https:/hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094125.png"
	
	
	
	loading="lazy"
	
		alt="https://hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094125.png"
	
	
></p>
<h2 id="指令集对比"><strong><code>指令集对比</code></strong></h2>
<h3 id="复杂指令集和精简指令集"><strong><code>复杂指令集和精简指令集</code></strong></h3>
<p><code>x86</code>是复杂指令集，主要是因为<code>x86</code>指令数量多、复杂指令、内存寻址方式多、指令长度不同等原因，导致硬件设计实现更复杂。使用复杂指令集主要是行业早期<code>技术限制</code>和<code>兼容性</code>原因导致的：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>原因</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>编译器技术落后</td>
<td>程序大多数都是以汇编语言或二进制码进行编写。提供一条复杂高级指令执行多个指令操作，可以使程序开发更加便利。</td>
</tr>
<tr>
<td>内存紧张</td>
<td>程序需要加载到内存中执行，内存不足导致需要尽可能降低程序的二进制大小减少内存占用。复杂指令是可变长度，大部分指令的二进制位数更短，只有复杂指令会使用更长的二进制位数，这样可以增加指令的存储密度降低大小。</td>
</tr>
<tr>
<td>通用寄存器少</td>
<td>由于晶体管的成本导致通用寄存器数量很少，指令会更多的直接访问内存。导致更多的指令支持内存寻址，内存寻址方式更复杂。</td>
</tr>
<tr>
<td>兼容性</td>
<td>不断增加新的指令，同时还需要完全兼容老的指令，导致指令数量越来越多。</td>
</tr>
</tbody>
</table></div>
<p>以上这些原因导致早期使用<code>CSIC</code>将更多的复杂性转移到<code>CPU</code>处理，导致<code>CPU</code>设计复杂成本高。之后随着半导体技术的发展可以集成更多<code>晶体管</code>和<code>内存</code>以及<code>编译器</code>技术的发展可以更好的生成机器代码，<code>1979</code>年开始行业逐渐发现<code>CISC</code>有以下这些缺点：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>原因</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>通用寄存器数量少</td>
<td>更多的使用寄存器可以减少对内存的访问同时指令执行平均周期差异小也有利于流水线执行。</td>
</tr>
<tr>
<td>实现复杂度高</td>
<td>指令数量多/复杂指令，导致处理器实现复杂成本更高。同时也会增加编译器的复杂度</td>
</tr>
<tr>
<td>不利于流水线的设计</td>
<td>处理器流水线技术可以使处理器同一个周期内并行执行多个指令和操作流程，例如指令解码/内存读写/计算。指令长度不同和复杂指令会使解码器更复杂，指令执行周期差异大也不利于流水线并行执行</td>
</tr>
<tr>
<td>指令使用率低</td>
<td>程序的常用指令只占整个指令集的20%，造成了很多浪费</td>
</tr>
<tr>
<td>能效高</td>
<td>由于复杂度高需要使用更多的晶体管和复杂度，导致产生更多的功耗无法应付低功耗场景</td>
</tr>
</tbody>
</table></div>
<p>以上这些缺点推动了新的指令集都使用<code>RISC</code>设计更有利于提高处理器的性能和能效。但是<code>Intel</code>因为兼容性和软件生态的考虑选择继续使用<code>x86</code>。经过这些年处理器技术的发展，<code>x86</code>也做了非常多的技术改进提高性能，不过由于兼容性约束指令集很难缓慢的进行改进。</p>
<p><code>x86</code>的一些技术改进：</p>
<ul>
<li><code>降低指令复杂度</code>持续减少对一些老旧指令的兼容减少指令数量</li>
<li><code>内部使用精简指令集的设计</code>由于半导体工艺的发展芯片可以集成更多晶体管提高性能。增加了通用寄存器的数量、内部将复杂指令解码为多条简单指令用于流水线执行。</li>
<li><code>更多技术支持</code>提供了很多基于<code>Intel</code>平台的指令集扩展和开发框架，操作系统和软件开发者可以利用这些技术提高性能。</li>
</ul>
<p>指令差异</p>
<p>以下面的汇编为例。<code>RISC</code>指令集必须将内存数据加载到寄存器以后才能计算，<code>CISC</code>指令集可以支持指令内存寻址。所以<code>RISC</code>会生成更多的指令数量。</p>
<ul>
<li>CISC</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">mov eax, [num1]; 将num1的值加载到寄存器EAX中add eax, [num2]; 在寄存器EAX中执行加法操作mov [result], eax; 将结果存储到内存地址result处
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>RISC</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">lwnum1, [num1]; 将num1的值加载到寄存器R0中lwnum2, [num2]; 将num2的值加载到寄存器R1中addr0, r1; 在寄存器R0中执行加法操作swr0, [result]; 将结果存储到内存地址result处
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="指令集架构实现对比"><strong>指令集架构实现对比</strong></h3>
<p>因为<code>ARM</code>和<code>RISC-V</code>都是精简指令集设计上很接近，所以使用<code>x86-64</code>和<code>ARM64</code>来对比实现上的一些细节。</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>特性</th>
<th>x86-64</th>
<th>ARM64</th>
<th>影响</th>
</tr>
</thead>
<tbody>
<tr>
<td>指令位数</td>
<td>长度不同，至少8位</td>
<td>固定32位</td>
<td>可变长度导致解码器和指令读取复杂度更高</td>
</tr>
<tr>
<td>指令数量</td>
<td>几千个</td>
<td>几百个</td>
<td>ARM 主要是使用频率高的基础指令和少量指令扩展。x86除了基础指令还包含大量的复杂指令，同时为了兼容性需要支持很多老旧不再使用的指令</td>
</tr>
<tr>
<td>指令执行时间</td>
<td>简单指令大部分相同</td>
<td>基本相同</td>
<td>ARM大部分基础指令执行时间都在一个时钟周期。x86因为包含复杂指令执行时间不太一样，复杂指令可能会解码成多条微指令执行</td>
</tr>
<tr>
<td>通用寄存器数量</td>
<td>16</td>
<td>31</td>
<td>通用寄存器数量越多，可以将更多的临时数据存放在寄存器中减少对内存的读取提高性能</td>
</tr>
<tr>
<td>内存读写方式</td>
<td>寄存器、内存模式</td>
<td>寄存器操作</td>
<td>x86 很多指令都可以直接操作内存。ARM 必须使用LOAD/STORE将内存读取到寄存器或寄存器写入到内存中。不过现代流水线设计x86也会解码为多条微指令类似ARM的处理器方式</td>
</tr>
<tr>
<td>编译器复杂度</td>
<td>中</td>
<td>高</td>
<td>x86复杂度高导致编译器实现更复杂</td>
</tr>
<tr>
<td>CPU复杂度</td>
<td>高</td>
<td>中</td>
<td>x86指令数量更多/长度不同/复杂指令会导致CPU复杂度更高</td>
</tr>
<tr>
<td>程序二进制大小</td>
<td>中</td>
<td>高</td>
<td>对于x86的一条复杂指令，ARM可能会生成多条简单指令。所以 ARM 密度更低，指令二进制会更大导致程序更大一些</td>
</tr>
</tbody>
</table></div>
<h2 id="其他"><strong><code>其他</code></strong></h2>
<h3 id="cpu-遇到不支持的指令如何处理"><strong><code>CPU 遇到不支持的指令如何处理</code></strong></h3>
<p>指令集通常包含<code>基础指令集</code>和<code>扩展指令集</code>，基础指令集是使用最频繁的指令，扩展指令集是用于一些特定场景的指令集，例如<code>64位</code>和<code>SIMD</code>支持。通常<code>CPU核心</code>只会支持一部分扩展指令集，因为支持更多指令可能会增加额外的计算单元和寄存器，这会导致耗费更多的晶体管增加<code>成本</code>和<code>功耗</code>。同时一些使用频率低/成本高的扩展指令只用在部分追求高性能的场景。以下是两种情况：</p>
<ul>
<li><code>不支持部分扩展指令集</code>：<code>Intel</code>酷睿12系列开始不再支持<code>AVX-512</code>向量扩展，只有在更高级的<code>至强</code>处理器才支持。<code>AVX-512</code>需要多个<code>512</code>位寄存器，多个支持<code>512</code>位向量运算的计算单元。移除<code>AVX-512</code>指令扩展可以节省晶体管数量降低功耗或者将这些晶体管用于其他能力。</li>
<li><code>大小核差异化处理</code>：<code>高通</code>骁龙8gen2处理器，大核只支持<code>64</code>位，小核支持<code>32/64</code>位。<code>CPU</code>继续支持32位应用运行，32位应用可以继续在小核上运行。但是同时支持32/64位也会增加<code>CPU</code>的复杂度增加成本和功耗，所以在<code>8gen3</code>处理器中已经完全移除了对32位的支持。</li>
</ul>
<p>当<code>CPU</code>遇到不支持的指令如何处理，通常<code>CPU</code>会采用几种处理方式：</p>
<ul>
<li><code>抛出异常</code>直接抛出异常停止执行。</li>
<li><code>模拟执行</code>解码成更简单的指令进行模拟执行，但是可能会导致性能降低。</li>
</ul>
<h3 id="x86-和-arm-的性能"><strong><code>x86 和 ARM 的性能</code></strong></h3>
<p>当前总体来看能耗比<code>ARM</code>更优秀，高性能场景<code>x86</code>使用率更高。但是<code>指令集</code>对于<code>CPU</code>性能和功耗的影响会越来越小，<code>制造工艺</code>、<code>使用场景</code>、<code>兼容性</code>等因素也会导致<code>x86</code>和<code>ARM</code>平台的性能差异。</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>特性</th>
<th>x86-64</th>
<th>ARM64</th>
<th>影响</th>
</tr>
</thead>
<tbody>
<tr>
<td>制造工艺</td>
<td>最新 7nm</td>
<td>最新 3nm</td>
<td>Intel半导体工艺制程一直落后于台积电，ARM 芯片大多使用台积电最新工艺制造</td>
</tr>
<tr>
<td>使用场景</td>
<td>PC、服务器</td>
<td>移动设备、笔记本、嵌入式</td>
<td>x86面向高性能设计有更强大的散热能力，追求更高的峰值性能对于能耗的关注不够。ARM设备更多是面向低功耗的移动设备，续航和散热能力都有限，包括CPU、操作系统、设备都会使用面向高能效的设计。例如ARM会使用SOC、大小核、统一内存等有利于高能效的设计，操作系统基于高能效对CPU进行调度。</td>
</tr>
<tr>
<td>兼容性</td>
<td>兼容性负担重</td>
<td>兼容性负担轻</td>
<td>ARM平台最新的处理器已经不再32位，x86依然需要支持32位、部分16位模式、大量陈旧指令和模式</td>
</tr>
</tbody>
</table></div>
<p>随着<code>ARM</code>逐渐开始在高性能电脑和处理器市场占据更多的份额，也在不断的提升<code>CPU</code>性能。<code>x86</code>逐渐减少兼容性包袱同时也更加关注<code>能效比</code>。可能未来我们可以更清晰的理解指令集架构导致的性能和能耗差异。</p>
<h2 id="小结"><strong><code>小结</code></strong></h2>
<p>现代指令集架构也在互相借鉴，指令集之间的差异越来越小。<code>x86</code>CPU 内部会将复杂指令解码成多个简单指令执行有利于超标量 CPU 指令级并行，<code>ARM</code>也添加更多的指令以支持更多场景，<code>RISC-V</code>的设计者认为<code>ARMv8</code>借鉴了很多<code>RISC-V</code>的设计。</p>
<p>二进制翻译技术的使用也越来越多。<code>MacOS</code>提供<code>Rosetta 2</code>软件支持<code>x86</code>程序在<code>ARM</code>芯片上运行，虽然将<code>x86</code>指令转换成<code>ARM</code>指令会导致一定的性能损耗和兼容性问题（部分指令不支持），但是可以帮助大部分<code>x86</code>程序在<code>ARM</code>平台上正常运行。同时<code>Windows On ARM</code>也支持<code>x86</code>程序在<code>ARM</code>芯片上仿真执行。</p>
<p>同时从指令集版本升级特性也能看出，近些年指令集的变更主要是在提高<code>向量运算</code>指令应对越来越多的<code>AI</code>和<code>多媒体</code>场景，其他指令改进很少。</p>
<h1 id="处理器技术发展"><strong><code>处理器技术发展</code></strong></h1>
<p>处理器技术的发展主要是提高处理器的运行性能。对于如何提高处理器的性能，我们先用一个简单的公式来度量处理器的性能：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-markdown" data-lang="markdown"><span class="line"><span class="cl">	程序执行耗时 = 指令数 / CPI / 时钟频率
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>指令数</code>程序执行需要的指令总数</li>
<li><code>CPI</code>处理器平均每个时钟周期可以执行的指令数量（多核心也会增加CPI）</li>
<li><code>时钟频率</code>处理器一秒钟可以执行的周期次数</li>
</ul>
<p>因为指令数量无法控制，所以只能通过提高<code>CPI</code>和<code>时钟频率</code>来提升处理器的性能。接下来我们来了解处理器通过哪些技术来提高<code>CPI</code>和<code>时钟频率</code>。</p>
<h1 id="半导体工艺时钟频率能耗晶体管数量"><strong><code>半导体工艺、时钟频率、能耗、晶体管数量</code></strong></h1>
<h2 id="功耗时钟频率性能"><strong><code>功耗、时钟频率、性能</code></strong></h2>
<p>当前提升处理器性能遇到的最大的挑战就是<code>功耗墙</code>。电流通过晶体管会带来热量，太高的功耗导致处理器温度过高无法运行，同时移动设备电池技术发展也非常缓慢。我们先来看看处理器<code>动态功耗</code>计算公式，即处理器晶体管开关切换过程中产生的能耗：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-markdown" data-lang="markdown"><span class="line"><span class="cl">	功耗 = 晶体管数量 <span class="ge">* 电容 *</span> 电压^2 * 时钟频率
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>提示：这里只是一种简单的功耗工时，还需要考虑半导体制造工艺和漏电造成的影响。</p>
</blockquote>
<p>从功耗公式可以看出功耗和<code>晶体管数量</code>、<code>电容</code>、<code>电压</code>、<code>时钟频率</code>成正比，增加晶体管数量和提高频率都会增加处理器的功耗。</p>
<p>早期半导体工艺发展通过不断降低晶体管的尺寸可以减少<code>电容</code>的大小、以及降低晶体管开关切换时间，芯片可以使用更低的<code>电压</code>运行，通常每次工艺提升可以使电压降低<code>15%</code>。处理器制造商可以不断在芯片上增加<code>晶体管数量</code>以及提高<code>时钟频率</code>，同时控制功耗的增长速度。</p>
<p>半导体工艺发展带来的提升</p>
<ul>
<li><code>增加晶体管数量</code>在同样尺寸的芯片中集成更多数量的晶体管，这些增加的晶体管可以用于增加缓存大小、控制单元等模块提高处理器的性能。同时也推动了 SOC 芯片的发展，在芯片内集成多核心、GPU 等单元。</li>
<li><code>提高时钟频率</code>提高时钟频率可以使处理器执行的更快</li>
<li><code>降低电压</code>使用更低的电压进行运行，在同样的性能下可以降低能耗。同时更好的晶体管设计可以降低漏电。</li>
</ul>
<p>技术定律</p>
<blockquote>
<p>登纳德缩放定律：1974年罗伯特·登纳德发现，由于晶体管尺寸变小，在固定的芯片面积上增加晶体管的数量不会增加功耗。</p>
</blockquote>
<blockquote>
<p>摩尔定律：1965年戈登·摩尔预测，由于晶体管尺寸逐渐变小，同样面积的芯片上晶体管数量每隔一年翻一番，1975 年改为每隔两年翻一番。</p>
</blockquote>
<h2 id="功耗墙"><strong><code>功耗墙</code></strong></h2>
<p>从<code>2004</code>年开始<code>登纳德缩放定律</code>失效。缩短晶体管栅长本来能降低电压、提高晶体管开关频率，但在栅长缩短到<code>65nm</code>左右时，晶体管开关频率增加导致芯片功耗和温度急剧上升。同时，栅长缩短导致<code>漏电</code>流急剧增加，这些电能也会转化为热量。目前大概<code>40%</code>的功耗是由于漏电导致的，即使晶体管处于关闭状态也会增加漏电能耗。早期每一代新工艺至少可以让晶体管栅长缩小<code>30%</code>，虽然现在半导体制造商继续使用现有工艺节点乘以<code>0.7</code>作为下一代的节点名称，例如 10nm、7nm、5nm、3nm，然而栅长缩小尺寸已远远达不到这个要求，需要<code>二十年</code>左右才能使晶体管数量翻一番。同时每一代新技术节点的制造成本越来越高，每代制造成本相比前一代高几倍。</p>
<h2 id="小结-1"><strong><code>小结</code></strong></h2>
<p>由于<code>功耗墙</code>的限制，相同电压和电容条件下增加晶体管数量提高核心数量相比增加时钟频率带来的功耗影响更小。同时晶体管尺寸减少速度变缓，增加晶体管数量可能需要增加芯片的面积，但是增加芯片的面积会导致生产良率更低成本更高。处理器设计不再追求单核时钟周期快速提升，朝着<code>多核心</code>方向发展通过增加核心数提高指令吞吐量并行执行提高性能。</p>
<blockquote>
<p>提示：以功耗公式来计算，1GHz=10亿。Intel 2006 年推出的Core 2 E6700处理器时钟频率2.66 GHz、2个核心、2.9亿个晶体管。所以增加1个核心带来的功耗提高比增加时钟频率1GHz低。</p>
</blockquote>
<p>CPU能效曲线</p>
<p><img src="/https:/hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094235.png"
	
	
	
	loading="lazy"
	
		alt="https://hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094235.png"
	
	
></p>
<ul>
<li>更高的性能需要更高的<code>时钟频率</code>和<code>电压</code>运行，导致能效急剧提升</li>
</ul>
<p>时钟频率发展</p>
<p><img src="/https:/hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094253.png"
	
	
	
	loading="lazy"
	
		alt="https://hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094253.png"
	
	
></p>
<ul>
<li>处理器时钟频率提升幅度逐渐放缓</li>
</ul>
<p>半导体工艺发展</p>
<p><img src="/https:/hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094311.png"
	
	
	
	loading="lazy"
	
		alt="https://hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094311.png"
	
	
></p>
<p>半导体工艺发展主要是依赖光刻技术进步以及更优秀的晶体管设计，下面简单列一下<code>最近10年</code>半导体工艺发展的重要节点：</p>
<ul>
<li><code>32nm``2010</code>年<code>Intel</code>量产了首批<code>32nm</code>处理器第二代酷睿处理器，使用了<code>林本坚</code>发明的沉浸式光刻技术。</li>
<li><code>22nm``2011</code>年<code>Intel</code>首先在 22 纳米工艺节点上使用了<code>胡正明</code>发明的<code>FinFET</code>（鳍式场效晶体管）晶体管。<code>FinFET</code>减少<code>50%+</code>漏电并提高了性能。目前使用在<code>22nm</code>节点以下的半导体芯片中。</li>
<li><code>5nm``2020</code>年<code>台积电</code>使用<code>ASML</code>的新一代<code>EUV</code>光刻机，为苹果生产了第一个<code>5nm</code>处理器<code>A14</code>。相比<code>7nm</code>工艺密度提高<code>80%</code>、速度提高<code>15</code>、能耗降低<code>30%</code>。</li>
<li><code>3nm``2022</code>年<code>台积电</code>开始量产<code>3nm</code>芯片。</li>
<li><code>2nm``2025</code>年<code>台积电</code>计划开始量产<code>2nm</code>芯片，使用<code>GAAFET</code>（围栅场效晶体管）代替<code>FinFET</code>晶体管。<code>GAAFET</code>可以降低漏电、降低尺寸和提高性能。</li>
</ul>
<p>FinFET、GAAFET</p>
<p><img src="/https:/hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094421.png"
	
	
	
	loading="lazy"
	
		alt="https://hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094421.png"
	
	
></p>
<p>晶体管栅长发展</p>
<p><img src="/https:/hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094446.png"
	
	
	
	loading="lazy"
	
		alt="https://hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094446.png"
	
	
></p>
<ul>
<li>虽然晶体管制造技术节点在不断降低，但是栅长缩小速度越来越慢</li>
</ul>
<h1 id="指令级并行微架构和-ipc-提升"><strong><code>指令级并行：微架构和 IPC 提升</code></strong></h1>
<p><code>IPC</code>提升主要是提高指令的吞吐量，通过优化处理器流水线的微架构，提高一个周期可以执行的指令数量。</p>
<h2 id="流水线介绍"><strong><code>流水线介绍</code></strong></h2>
<p>在理解流水线之前我们先看简单了解一下程序执行的步骤。通常一个程序指令可能会经历五个执行步骤：</p>
<ul>
<li><code>读取指令</code>根据<code>PC</code>寄存器的地址，从内存中读取下一条执行指令到<code>CPU</code>中。</li>
<li><code>解码指令</code>将二进制指令解码成具体需要执行的指令，复杂指令可能需要解码为多条指令。</li>
<li><code>执行指令</code>调用执行单元进行运算。</li>
<li><code>读写内存数据</code>从内存中读写计算的数据。</li>
<li><code>写寄存器</code>将运算完的数据写会寄存器。</li>
</ul>
<p>早期的<code>CPU</code>设计只能按照程序指令的顺序进行执行，每个指令都需要经过这五个执行步骤。如果每个步骤需要<code>200ps</code>的话，一个时钟周期需要<code>1000ps</code>并且只能执行<code>1</code>个指令。<code>3</code>个指令需要<code>3000ps</code>。之后就诞生了<code>流水线</code>技术，通过在一个时钟周期内执行多条不同指令的不同步骤，提高流水线的吞吐量实现指令集并行。虽然不能降低单个指令的耗时，但是可以降低多条指令的总耗时。</p>
<p>五级流水线优化执行</p>
<p><img src="/https:/hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094532.png"
	
	
	
	loading="lazy"
	
		alt="https://hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094532.png"
	
	
></p>
<ul>
<li>理想情况下三条指令在每个周期都执行多个不同的步骤，降低了三条执行执行的总耗时</li>
<li>一个时钟周期的耗时取决于这个周期内最长耗时的操作</li>
</ul>
<h2 id="现代流水线设计"><strong><code>现代流水线设计</code></strong></h2>
<p>现代<code>CPU</code>核心中的流水线设计很复杂，也会导致<code>CPU</code>中的控制单元占比很大。现代<code>CPU</code>流水线设计主要为了让运算单元每个周期都可以满负载执行，通常有<code>10</code>级流水线，加入了更多的功能模块用于增加流水线的吞吐量提高<code>IPC</code>。流水线通常分为<code>前端</code>和<code>后端</code>，前端主要负责<code>读取指令</code>和<code>解码指令</code>，<code>后端</code>主要负责调度<code>发射指令</code>和<code>执行指令</code>。接下来我们通过下图的流水线示例来了解现代<code>CPU</code>中的流水线设计，参考了当前主流的<code>CPU</code>性能核心的微架构实现。</p>
<p><img src="/https:/hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094553.png"
	
	
	
	loading="lazy"
	
		alt="https://hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094553.png"
	
	
></p>
<blockquote>
<p>提示：Intel最早在2004年推出了30+级流水线的CPU，但是流水线数量太长会导致微架构设计非常复杂，同时分支预测失败惩罚更高。这些原因导致目前CPU通常使用10级左右的流水线。</p>
</blockquote>
<h3 id="读取指令"><strong><code>读取指令</code></strong></h3>
<p><code>读取指令</code>将内存中的指令读取到<code>CPU</code>中的<code>指令缓冲区中</code>，相关的优化是为了降低读取指令延迟和读取更多指令到<code>CPU</code>中，提高流水线的吞吐量。</p>
<h3 id="多指令读取"><strong><code>多指令读取</code></strong></h3>
<p>由于从内存中读取程序指令延迟比较长，现代<code>CPU</code>会按照<code>PC</code>寄存器的地址一次性读取多条后面需要执行的程序指令<code>CPU</code>中，减少后续流水线空闲时间。将指令放在<code>指令缓冲区</code>中，等待解码器的使用。</p>
<h3 id="分支预测"><strong><code>分支预测</code></strong></h3>
<p>由于一次性读取多条程序指令，会遇到一个问题就是当分支判断的时候由于分支还未执行无法知道后续分支执行的方向。通过添加<code>分支预测</code>单元提前预测分支可能的执行方向读取后续需要执行的程序指令。</p>
<p><code>分支预测</code>分为<code>动态分支预测</code>和<code>静态分支预测</code>。高性能<code>CPU</code>核心都会使用<code>动态分支预测</code>的方式，分支预测成功率可以达到<code>80%-90%</code>。<code>分支预测</code>错误会导致分支预测惩罚需要回滚错误分支的指令执行，通常会导致<code>10+</code>个周期的流水线惩罚。</p>
<p>静态分支预测和动态分支预测</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>类型</th>
<th>实现方式</th>
<th>优点</th>
<th>缺点</th>
<th>详情</th>
</tr>
</thead>
<tbody>
<tr>
<td>静态分支预测</td>
<td>编译器</td>
<td>实现简单、成本低</td>
<td>预测准确性比较差</td>
<td>在编译器中插入相关分支预测判断</td>
</tr>
<tr>
<td>动态分支预测</td>
<td>CPU</td>
<td>预测成功率高</td>
<td>成本高、增加功耗</td>
<td>一种简单实现：在每个分支执行完成的时候，将分支结果保存到缓存中进行统计。分支预测执行判断时，根据之前这个分支的执行结果选择概率更高的执行方向。</td>
</tr>
</tbody>
</table></div>
<h3 id="l1-指令缓存"><strong><code>L1 指令缓存</code></strong></h3>
<p>为了避免每次从内存中读取指令延迟比较长，将读取过的指令存入缓存中。经常使用的指令就可以直接从缓存中读取，但是<code>L1缓存</code>由于读取性能的限制容量有限，通常只有几十KB，在<code>缓存缺失</code>的时候可能会从内存中读取指令导致流水线卡顿。</p>
<h3 id="tlb-缓存"><strong><code>TLB 缓存</code></strong></h3>
<p>由于<code>CPU</code>访问内存时，会将程序空间的虚拟地址映射为物理内存地址，这个映射过程有一定的耗时。通过加入<code>TLB</code>缓冲区将转换后的映射加入到缓存中，下次读取程序指令地址时就可以直接读取无需再进行地址转换。</p>
<h3 id="解码指令"><strong><code>解码指令</code></strong></h3>
<p><code>解码指令</code>将<code>指令缓冲区</code>中的指令按照顺序微码为多个微操作放入微操作队列中，相关的优化是为了降低解码耗时和同时解码更多的指令。</p>
<h3 id="预解码"><strong><code>预解码</code></strong></h3>
<p>将<code>指令缓冲区</code>中几十个字节的指令解析成多个单独的程序指令，后续再发送到解码器提高解码效率。特别是对于<code>x86</code>指令由于指令长度不同，预解码阶段会更加复杂。</p>
<h3 id="多解码器"><strong><code>多解码器</code></strong></h3>
<p><code>解码器</code>将程序指令解码成<code>CPU</code>微操作指令。现代<code>CPU</code>核心中通常会添加多个解码器用于提高解码性能，通常会有<code>3-10</code>个解码器单个时钟周期可以解码多条指令。</p>
<p><code>x86</code>平台的复杂指令可能会生成多条微操作，所以<code>x86</code>处理器通常包含一个复杂指令解码器，专门用于解码复杂指令。<code>x86</code>处理器的解码器通常比<code>ARM</code>更少，<code>A17 Pro</code>的高性能核有<code>9</code>个解码器，<code>Intel i9 14900K</code>的高性能核心只有<code>6</code>个解码器其中包含<code>1</code>个复杂指令解码器。</p>
<h3 id="微指令缓存"><strong><code>微指令缓存</code></strong></h3>
<p><code>x86</code>平台由于复杂指令的存在，解码指令效率更低。通常会加入额外的微指令缓存，将已经解码的指令微操作映射保存到缓存中，下次可以直接读取无需再解码。</p>
<h3 id="发射指令"><strong><code>发射指令</code></strong></h3>
<h3 id="多发射"><strong><code>多发射</code></strong></h3>
<p>一个周期内发射多个指令到运算单元，提高运算单元的吞吐量。有两种实现多发射的调度方式，<code>静态调度</code>和<code>动态调度</code>。现代<code>CPU</code>高性能核心使用<code>动态调度</code>一个周期可以发射<code>6-10</code>个指令。</p>
<p>静态调度和动态调度</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>类型</th>
<th>实现方式</th>
<th>优点</th>
<th>缺点</th>
<th>详情</th>
</tr>
</thead>
<tbody>
<tr>
<td>静态调度</td>
<td>编译器</td>
<td>实现成本更低</td>
<td>性能提升一般</td>
<td>编译器对指令的执行顺序进行调整</td>
</tr>
<tr>
<td>动态调度</td>
<td>CPU</td>
<td>性能更好</td>
<td>成本高、增加功耗</td>
<td>CPU实时对指令进行调度和发射</td>
</tr>
</tbody>
</table></div>
<h3 id="动态调度"><strong><code>动态调度</code></strong></h3>
<p>多发射调度主要是为了提高指令发射的效率，同一个<code>时钟周期</code>发射出更多的指令到<code>计算单元</code>，让<code>计算单元</code>持续处于高负载运算状态中提高吞吐量。一个时钟周期内将不同的指令发射到不同的<code>计算单元</code>，但是需要解决<code>流水线冒险</code>带来的挑战，通常存在三种类型的流水线冒险：</p>
<ul>
<li><code>数据冒险</code>当前指令必须依赖前面一条正在执行的指令的计算结果，例如依赖前一条加法指令的计算结果，需要等待前一个指令将结果写入到寄存器中。</li>
<li><code>控制冒险</code>当前指令必须依赖前面一条正在执行的指令的分支判断结果，通常使用<code>分支预测</code>方式进行解决。</li>
<li><code>结构冒险</code>当前指令因为硬件资源限制导致无法执行，例如多个指令需要同时使用同一个寄存器，多个指令需要同时使用某个加法计算单元。</li>
</ul>
<p>流水线调度过程中需要解决<code>流水线冒险</code>的问题，现代<code>CPU</code>微架构设计会通过<code>ROB</code>（重排序缓冲区）对执行进行动态调度，<code>ROB</code>越大可以保存的指令数越多性能越好：</p>
<ul>
<li><code>寄存器重命名</code>现代<code>CPU</code>内核中通常有更多的物理寄存器数量，超过<code>指令集</code>中定义的寄存器数量。需要对<code>寄存器</code>进行重命名放置到不同的寄存器中提高指令级并行，例如两条指令都使用同一个寄存器可以放置到不同的寄存器中进行处理。</li>
<li><code>指令重排序</code>因为需要同时发射多条指令提高吞吐量，所以需要对指令的执行顺序进行调整导致<code>乱序执行</code>。但是会保证最终的执行结果符合原本的预期。</li>
<li><code>数据预读取</code>提前将后面程序指令需要使用的内存数据加载到缓存中，避免<code>缓存缺失</code>导致的延时。</li>
<li><code>分支预测惩罚</code>流水线执行过程中会将分支预测相关的指令执行结果暂时保存，等待最终分支预测正确时才会执行完成。如果<code>分支预测</code>错误需要回滚这些错误预测的指令。</li>
<li><code>指令发射</code>将对应的指令发射到计算单元</li>
</ul>
<h3 id="执行指令"><strong><code>执行指令</code></strong></h3>
<h3 id="多执行"><strong><code>多执行</code></strong></h3>
<p>一个时钟周期可以并行执行不同的计算单元，只要当前计算单元有空闲。</p>
<h3 id="计算单元缓冲区"><strong><code>计算单元缓冲区</code></strong></h3>
<p>将指令和指令数据发射到计算单元的缓冲区中等待执行，当计算单元空闲时即可开始执行。</p>
<h3 id="增加计算单元"><strong><code>增加计算单元</code></strong></h3>
<p>增加更多的<code>整数运算</code>、<code>浮点运算</code>、<code>分支判断</code>和<code>内存读写</code>单元数量，一个时钟周期可以执行更多的运算和内存读写操作。现代<code>CPU</code>性能核心通常有<code>10+</code>个算数单元和多个内存加载单元。</p>
<h3 id="l1l2-数据缓存"><strong><code>L1/L2 数据缓存</code></strong></h3>
<p>通过<code>L1</code>、<code>L2</code>缓存读取内存数据，将常用的数据保存到高速缓存中，提高下一次读取的性能。</p>
<h2 id="主流-cpu-核心的微架构设计"><strong>主流 CPU 核心的微架构设计</strong></h2>
<p>现代<code>CPU</code>通常使用<code>大小核</code>设计，<code>性能核</code>有更复杂的流水线设计性能更好，<code>能效核</code>流水线设计更简单性能会差一些。</p>
<h3 id="intel"><strong>Intel</strong></h3>
<p><code>Intel</code>最新的桌面级别处理器<code>Core i9 14900K</code>使用了<code>8</code>个<code>Raptor Cove</code>性能核和<code>16</code>个<code>Gracemont</code>能效核。</p>
<p>Raptor Cove性能核</p>
<p><img src="/https:/hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094644.png"
	
	
	
	loading="lazy"
	
		alt="https://hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094644.png"
	
	
></p>
<p>Gracemont 能效核</p>
<p><img src="/https:/hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094720.png"
	
	
	
	loading="lazy"
	
		alt="https://hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094720.png"
	
	
></p>
<h3 id="apple"><strong>Apple</strong></h3>
<p><code>Apple</code>最新的<code>A17 Pro</code>处理器使用了<code>2</code>个性能核和<code>4</code>个能效核。</p>
<p>性能核</p>
<p><img src="/https:/hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094739.png"
	
	
	
	loading="lazy"
	
		alt="https://hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094739.png"
	
	
></p>
<p>能效核</p>
<p><img src="/https:/hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094800.png"
	
	
	
	loading="lazy"
	
		alt="https://hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094800.png"
	
	
></p>
<h3 id="arm-1"><strong>ARM</strong></h3>
<p><code>高通</code>最新的<code>8 Gen 3</code>处理器使用了<code>1</code>个<code>X4</code>超大核，<code>5</code>个<code>A710</code>性能核，<code>2</code>个<code>A520</code>能效核。</p>
<p>X4 超大核</p>
<p><img src="/https:/hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094820.png"
	
	
	
	loading="lazy"
	
		alt="https://hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094820.png"
	
	
></p>
<p>A720 性能核</p>
<p><img src="/https:/hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094856.png"
	
	
	
	loading="lazy"
	
		alt="https://hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094856.png"
	
	
></p>
<p>A520 能效核</p>
<p><img src="/https:/hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094914.png"
	
	
	
	loading="lazy"
	
		alt="https://hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094914.png"
	
	
></p>
<h2 id="小结-2"><strong><code>小结</code></strong></h2>
<p><code>CPU</code>核心微架构通过加入更多的流水线单元提高<code>IPC</code>，这些优化单元都需要消耗额外的晶体管数量增加能耗，同时<code>IPC</code>更高的核心会使用更高的时钟频率运行。在<code>20世纪90年代</code>流水线技术的发展带来了处理器性能的快速提升，但是随着<code>功耗墙</code>的限制，高性能核心在性能上比能效核心快几倍，但是在功耗上可能有几十到上百倍的消耗。<code>CPU</code>技术发展不再追求大幅提高<code>IPC</code>来提高性能，而是转向对晶体管更好的利用追求能耗比。</p>
<p>从现代<code>CPU</code>的微架构设计中也能看到，不同指令集的<code>CPU</code>在微架构上也有很多相似之处，更多的差异在解码单元对于不同指令的解码。</p>
<blockquote>
<p>提示：IPC高的核心需要使用更高的时钟频率进行执行，主要是因为IPC高的核心有更复杂流水线设计和更积极的流水线调度避免流水线停顿，所以提高时钟频率可以提升性能。IPC低的核心会遇到更多的流水线停顿，提高频率也会导致很多周期流水线处于停顿等待内存读取或分支计算完成造成浪费。</p>
</blockquote>
<h1 id="数据级并行simd-和-gpu"><strong><code>数据级并行：SIMD 和 GPU</code></strong></h1>
<h2 id="simd"><strong><code>SIMD</code></strong></h2>
<p><code>SIMD</code>(Single instruction, multiple data)单指令多数据，是一种通过单个指令同时进行多个数据运算的方式，主要是用于音视频、图像处理、向量运算这些计算场景。通过增加运算单元位宽、计算单元数量数量、寄存器位宽可以同时进行更多数据的运算，普通指令单个周期通常只能支持 2个数据的运算，<code>SIMD</code>指令单个周期可以同时几十个数据的运算。同时一次性读取多个内存数据也可以降低多次读取内存数据带来的数据延迟。大部分常见<code>编程语言</code>都提供对<code>SIMD</code>的支持，可以直接进行使用。</p>
<p>很多图像、音视频等场景，通常只需要更低的数据位宽进行运算，<code>SIMD</code>指令可以同时进行更多数据的运算。目前<code>x86</code>平台的<code>SIMD</code>指令发展到最新的<code>AVX-512</code>，运算宽度提升到 512 位，可以单指令执行 512 位的运算。<code>ARM</code>平台的<code>SIMD</code>指令发展到<code>SSE</code>，最高可执行<code>2048</code>位的运算。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">例如一个像素值颜色通常使用 RGBA 32 位格式，Red、Green、Blue、Alpha分别占 8 位。一个 256 位的 SIMD 指令可以同时对 8 个颜色（32 个 8 位）进行运算，普通指令只能进行 2 个 8 位运算。
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>SIMD</code>虽然带来了性能的提升，但是芯片需要使用更多的晶体管用来支持<code>SIMD</code>指令更高的位宽计算和更多的寄存器数量。同时<code>SIMD</code>指令一次性传输数据量更大、指令复杂度更高、占用更多的寄存器和运算器，也带来了更多的计算功耗。<code>SIMD</code>也需要软件开发者针对特定场景选择使用<code>SIMD</code>指令进行优化才能得到性能提升。</p>
<p>普通运算和 SIMD 运算的区别</p>
<p><img src="/https:/hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094936.png"
	
	
	
	loading="lazy"
	
		alt="https://hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094936.png"
	
	
></p>
<h2 id="gpu"><strong><code>GPU</code></strong></h2>
<p>从某种角度讲，<code>SIMD</code>和<code>GPU</code>的运算方式很相似。通过一次性并行处理更多的数据带来性能提升，同时一次性读取大量数据也可以降低内存数据延迟带来的影响。<code>GPU</code>很像同时并行多线程执行<code>SIMD</code>的多核心处理器，只不过相比<code>CPU</code>设计更复杂性能更高，同时<code>GPU</code>的线程数更多、<code>SIMD</code>通道数更多、<code>SIMD</code>单元数量更多。</p>
<p>SIMD 和 GPU</p>
<p><img src="/https:/hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094952.png"
	
	
	
	loading="lazy"
	
		alt="https://hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222094952.png"
	
	
></p>
<h2 id="小结-3"><strong><code>小结</code></strong></h2>
<p>近些年更多<code>AI</code>运算场景增加了对于高性能向量运算的要求。虽然<code>CPU</code>通过添加<code>SIMD</code>指令增加了向量运算的能力，但是<code>CPU</code>本身是用于通用计算设计，<code>CPU</code>中只有小部分用于<code>SIMD</code>运算。虽然类似<code>Pytorch</code>、<code>TensorFlow</code>这些<code>AI</code>训练框架都支持<code>SIMD</code>指令，但是使用<code>SIMD</code>进行大规模<code>AI</code>训练相比<code>GPU</code>性能更低，同时成本更高。<code>SIMD</code>更像是传统<code>CPU</code>运算的一种补充，用于简单的小规模运算场景用于提高性能。</p>
<h1 id="多线程并行超线程多核心"><strong><code>多线程并行：超线程、多核心</code></strong></h1>
<h2 id="超线程"><strong><code>超线程</code></strong></h2>
<p><code>超线程</code>是一种<code>STM</code>(同时多线程)技术，通过在单个<code>CPU</code>核心中模拟运行多个线程提高<code>CPU</code>的多线程并行能力。<code>Intel</code>最早在<code>2002</code>年推出了超线程技术，一个核心同时支持<code>2</code>个线程。利用<code>SMT</code>可以避免处理器中长延时事件导致的暂停，提高计算单元的利用率。</p>
<p><code>超线程</code>技术通过给每个线程增加一套<code>寄存器</code>和<code>PC</code>单元，多个线程共享流水线中的<code>多发射</code>、<code>动态调度</code>等模块，通过寄存器重命名和动态调用可以在一个周期内执行不同线程的多条指令。减少单个线程中发生类似<code>缓存缺失</code>这样的长延时等待事件，让计算单元一直在执行状态提高性能和吞吐量。</p>
<p><code>超线程</code>技术会增加流水线调度的复杂度，现代<code>CPU</code>核心通常只支持<code>2</code>个线程的<code>SMT</code>。<code>超线程</code>技术需要依赖流水线的动态调度能力，所以现代<code>CPU</code>中通常只有高性能核心才支持。同时<code>超线程</code>技术虽然可以提高<code>20%-30%</code>的多线程性能，但是会增加<code>7%</code>的能耗和降低<code>单核</code>峰值性能。</p>
<p>超线程调度</p>
<p><img src="/https:/hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222095013.png"
	
	
	
	loading="lazy"
	
		alt="https://hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222095013.png"
	
	
></p>
<ul>
<li><code>粗粒度多线程</code>只有流水线发生等待事件长的停顿时才切换线程</li>
<li><code>细粒度多线程</code>每个时钟周期都切换线程</li>
</ul>
<h2 id="多核心"><strong><code>多核心</code></strong></h2>
<p>由于<code>IPC</code>提升和<code>时钟频率</code>提升都因为<code>功耗墙</code>的限制而放缓，现代<code>CPU</code>通过提供更多的物理核心提高多线程并行能力提升指令吞吐量提高性能。通过增加<code>CPU</code>核心数带来的多线程性能提升，带来的能耗增加相比提升<code>IPC</code>、<code>时钟频率</code>更低。现在手机端<code>CPU</code>中也有<code>5-9</code>个核心，PC 级<code>CPU</code>中通常有<code>10-30</code>个核心，服务器<code>CPU</code>中核心数更多。</p>
<p>增加核心数可以复用核心内部的微架构设计，根据<code>CPU</code>的功耗、成本、性能诉求选择核心数量。例如<code>Intel</code>在桌面级酷睿处理器和服务器至强处理器可能会使用同样的核心，只是会增加更多的核心数量。<code>Apple</code>在<code>A</code>系列和<code>M</code>系列芯片也会使用同样的核心。</p>
<p>增加核心数也能带来一定的能耗优势，操作系统<code>内核</code>会根据运算负载动态的调度不同数量的核心进行执行，在运算负载低的时候可以调度更少的核心降低功耗。</p>
<h3 id="大小核"><strong><code>大小核</code></strong></h3>
<p>现代<code>CPU</code>中通常还会使用<code>大小核</code>异构架构设计来提升能耗比降低功耗。<code>性能</code>核心用于高性能计算场景最大化执行性能，<code>能耗</code>核心用于日常低负载计算场景降低能耗。相同的核心会使用同样的<code>时钟频率</code>来运行，通常会共享使用<code>L2缓存</code>。<code>大小核</code>的设计也增加了操作系统<code>内核</code>对于多核心调度的难度。</p>
<p>性能核心、能效核心区别</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>类型</th>
<th>性能</th>
<th>功耗</th>
<th>时钟频率</th>
<th>IPC</th>
</tr>
</thead>
<tbody>
<tr>
<td>性能核</td>
<td>高</td>
<td>高</td>
<td>更高的时钟频率</td>
<td>复杂的流水线设计、IPC 更高</td>
</tr>
<tr>
<td>能耗核</td>
<td>中</td>
<td>中</td>
<td>更低的时钟频率</td>
<td>简单的流水线设计、IPC 更低（更少的解码宽度、没有动态调度、更少的计算单元等）</td>
</tr>
</tbody>
</table></div>
<p>大小核设计</p>
<p><img src="/https:/hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222095039.png"
	
	
	
	loading="lazy"
	
		alt="https://hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222095039.png"
	
	
></p>
<h2 id="小结-4"><strong><code>小结</code></strong></h2>
<p>近些年<code>CPU</code>通过增加更多的核心数量提高<code>CPU</code>的多线程并行能力，但是这也带来了一些新的问题限制了核心数一直快速增加。首先<code>CPU</code>核心数更多增加<code>缓存一致性</code>的复杂度会影响性能，<code>操作系统</code>内核如何更好的对更多核心进行调度达到最高的能耗比。</p>
<p>同时对于<code>软件开发者</code>来讲，利用越来越多的核心进行编程会更复杂。编程语言以及开发框架也需要进行调整利用更多的核心。同时对于不同的软件类型，可以利用多线程并行执行的部分也是不一样的。（如果一个程序只有<code>10%</code>的运算工作可以并行执行，即使添加更多核心带来的提升也很有限）</p>
<p>虽然增加核心数带来的能耗增加相比<code>IPC</code>、<code>时钟频率</code>更低，但是依然会增加功耗，<code>功耗墙</code>也是限制核心数增加的限制之一。</p>
<h1 id="高速缓存和内存提升"><strong><code>高速缓存和内存提升</code></strong></h1>
<p>虽然内存不属于处理器内部的结构，但是处理器运行时会依赖内存中的程序指令和程序数据，所以内存性能对处理器性能的影响很大。因为内存性能提升相比处理器<code>时钟频率</code>提升非常缓慢，当前处理器对内存读写通常需要<code>50-100个</code>时钟周期。关于<code>内存访问速度</code>的提升，一个方向是通过引入<code>多级缓存</code>减少处理器对内存的直接访问，另一个方向是内存自身性能的提升。</p>
<h2 id="引入高速缓存"><strong><code>引入高速缓存</code></strong></h2>
<p>为了减少处理器对内存的直接访问，现代处理器引入了<code>SDRAM（Synchronous dynamic random-access memory）</code>存储作为处理器的缓存集成在处理器芯片中。<code>SDRAM</code>的优点是访问速度比内存快很多，缺点是<code>功耗高</code>、<code>成本高</code>（1位需要 6-7 个晶体管）、<code>容量低</code>。</p>
<p>处理器对内存的所有访问都通过缓存进行加载，缓存会保存最近使用过的内存数据，这样下次访问这些数据时就可以直接从缓存中返回避免直接从内存中读取。</p>
<h3 id="内存读写过程"><strong>内存读写过程</strong></h3>
<p>以下是一个简单的具有<code>二级缓存</code>的处理器内存读写过程原型，不过现代处理器设计通常会比这个过程更加复杂：</p>
<p>读取</p>
<ul>
<li><code>L1</code>处理器核心需要读取数据时，将数据内存地址发送给<code>L1缓存</code>。<code>L1缓存</code>检查是否有缓存数据，如果<code>L1缓存</code>中有缓存数据直接返回。如果缓存缺失将数据内存地址发送给<code>L2</code>。</li>
<li><code>L2``L2缓存</code>检查是否有缓存数据。如果<code>L2缓存</code>中有缓存数据将数据写入<code>L1缓存</code>同时读取到处理器中。如果缓存缺失将数据内存地址发送给<code>内存</code>。</li>
<li><code>内存</code>从内存中读取数据，之后分别写入<code>L2缓存</code>、<code>L1缓存</code>，然后读取到处理器中。</li>
</ul>
<p>保存</p>
<p>处理器核心将寄存器中的数据保存到内存时，分别写入<code>L1缓存</code>、<code>L2缓存</code>，之后保存到内存中。</p>
<h3 id="缓存提升方向"><strong><code>缓存提升方向</code></strong></h3>
<p>缓存性能提升方向主要是<code>提高缓存命中率</code>、<code>降低缓存缺失耗时</code>、<code>降低缓存命中耗时</code>，主要是通过以下这些技能进行提升：</p>
<p>增加容量</p>
<p>增加缓存的容量，缓存中可以存储的数据越多，<code>缓存命中率</code>也就越高。功耗和成本会限制容量增长的速度，同时因为增加容量会影响访问速度，所以<code>L1</code>缓存容量增长很慢。</p>
<p>使用多级缓存</p>
<p>现代处理器通常有<code>2-3</code>级缓存，多核处理器每个核心包含一个<code>L1</code>缓存，<code>L2</code>、<code>L3</code>缓存是多个核心共享。读取速度<code>L1 &gt; L2 &gt; L3</code>，容量<code>L3 &gt; L2 &gt; L1</code>，成本<code>L1 &gt; L2 &gt; L3</code>。</p>
<p>这么设计的目的主要是通过<code>局部性原理</code>提高缓存性能。<code>L1</code>缓存关注读取性能，将更常用的内存数据放到容量更小的<code>L1</code>缓存中更快的读取。同时<code>L1</code>缓存设计会将<code>指令</code>和<code>数据</code>分离，提高缓存性能和缓存命中率。<code>L2</code>/<code>L3</code>缓存关注缓存缺失率，将更多的内存数据防止在缓存中减少<code>缓存缺失耗时</code>。</p>
<blockquote>
<p>时间局部性- 被引用过一次的内存数据在未来会被多次引用。</p>
</blockquote>
<blockquote>
<p>空间局部性- 一个内存数据被引用，那么未来它临近的内存地址也会被引用。</p>
</blockquote>
<p>现代<code>CPU</code>多级缓存设计</p>
<p><img src="/https:/hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222095059.png"
	
	
	
	loading="lazy"
	
		alt="https://hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222095059.png"
	
	
></p>
<blockquote>
<p>提示：通常L1缓存是单核心独占、L2缓存可能是单核心独占或多核心共享、L3缓存/内存是所有核心共享。通过MESI协议来解决缓存一致性的问题。</p>
</blockquote>
<p>多级缓存和内存性能</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>存储类型</th>
<th>访问速度</th>
<th>容量</th>
<th>功能</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>L1</td>
<td>1 - 5 时钟周期</td>
<td>64 - 256 KB</td>
<td>指令、数据</td>
<td>-</td>
</tr>
<tr>
<td>L2</td>
<td>10 - 20 时钟周期</td>
<td>512 KB - 2 MB</td>
<td>数据</td>
<td>A17 Pro 大核16MB</td>
</tr>
<tr>
<td>L3</td>
<td>20 - 50 时钟周期</td>
<td>12 - 36 MB</td>
<td>数据</td>
<td>-</td>
</tr>
<tr>
<td>DDR</td>
<td>50 - 100 时钟周期</td>
<td>8 - 64 GB</td>
<td>指令、数据</td>
<td>-</td>
</tr>
</tbody>
</table></div>
<p>降低缓存命中时间</p>
<p>通过更优秀的缓存涉及，减少缓存命中时的耗时。但是通常减少命中缓存耗时和增加缓存容量通常会有不可调和的矛盾。</p>
<p>缓存预加载</p>
<p>根据前面流水线的介绍，现代处理器通常会对一次性读取内存多条程序指令到放入缓存中，同时也会提前读取后面可能会使用的内存数据到缓存中。但是当提前预加载到缓存中的数据并没有使用到时，会造成额外的功耗浪费。（例如分支预测错误）</p>
<p>优化缓存更新算法</p>
<p>将新的数据写入到缓存时，由于容量限制通常需要替换掉旧的缓存数据。常见的替换算法有<code>LRU</code>算法，使用更好的算法可以提高<code>缓存命中率</code>。</p>
<h2 id="内存性能提升"><strong><code>内存性能提升</code></strong></h2>
<p>虽然通过加入多级缓存可以提高内存读写的性能，但是处理器高速缓存的容量很有限，遇到缓存缺失时还是需要直接访问内存。所以对内存的性能提升依然很重要，内存性能提升主要是从以下四个方向进行提升：</p>
<ul>
<li><code>读取延迟</code>持续减少内存读取延迟，可以降低<code>缓存缺失</code>从内存中读取数据的耗时。</li>
<li><code>功耗</code>由于移动设备等低功耗场景的出现，对内存产生的<code>功耗</code>也有更低的要求。</li>
<li><code>带宽</code>因为内存性能提升很慢，同时现代处理器不断的引入新的协处理器例如<code>GPU</code>、<code>NPU</code>需要进行更多的内存数据传输。增加内存带宽虽然无法降低单次内存读取延迟但是可以同时传输更多的数据。</li>
<li><code>成本</code>更低的成本可以使商品价格更低，同时可以增加更多的内存容量。</li>
</ul>
<h3 id="更多内存类型"><strong><code>更多内存类型</code></strong></h3>
<p>由于内存无法同时满足对<code>延迟</code>、<code>功耗</code>、<code>带宽</code>、<code>成本</code>的要求，现代内存逐渐发展出了多种不同的内存类型。针对不同的计算场景选择使用不同类型的内存，主要是基于处理器对<code>延迟</code>、<code>功耗</code>、<code>带宽</code>、<code>成本</code>的要求进行选择。每一代内存新标准的推出也会逐渐提高<code>延迟</code>、<code>功耗</code>、<code>带宽</code>的性能，同时降低上一代标准的<code>成本</code>。(通常新标准成本更高)</p>
<p>不同内存类型特点</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>类型</th>
<th>最新标准</th>
<th>延迟</th>
<th>功耗</th>
<th>带宽</th>
<th>最大带宽</th>
<th>面积</th>
<th>成本</th>
<th>使用场景</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>DDR</td>
<td>DDR5</td>
<td>低</td>
<td>中</td>
<td>低</td>
<td>64 Gbps</td>
<td>中</td>
<td>低</td>
<td>PC、服务器</td>
<td>延迟最低</td>
</tr>
<tr>
<td>LPDDR</td>
<td>LPDDR5X</td>
<td>中</td>
<td>低</td>
<td>中</td>
<td>77 Gbps (8 Gen 3)</td>
<td>小</td>
<td>低</td>
<td>手机、笔记本</td>
<td>功耗最低</td>
</tr>
<tr>
<td>GDDR</td>
<td>GDDR6X</td>
<td>高</td>
<td>高</td>
<td>高</td>
<td>1008 Gbps（RTX 4090）</td>
<td>大</td>
<td>中</td>
<td>独立显卡</td>
<td>高带宽、功耗最高、延迟最高</td>
</tr>
<tr>
<td>HBM</td>
<td>HBM3e</td>
<td>高</td>
<td>中</td>
<td>超高</td>
<td>4800 Gbps（H200）</td>
<td>小</td>
<td>高</td>
<td>服务器GPU</td>
<td>带宽最高、成本最高</td>
</tr>
</tbody>
</table></div>
<h3 id="集成封装工艺提升"><strong><code>集成封装工艺提升</code></strong></h3>
<p>现代面向移动场景的处理器通常会将<code>LPDDR</code>内存使用<code>3D</code>集成封装技术直接集成到处理器芯片上。优点是可以减少传输物理距离提高传输性能、降低功耗，缺点是无法灵活更换内存。</p>
<p>内存集成封装到处理器芯片上</p>
<p><img src="/https:/hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222095134.png"
	
	
	
	loading="lazy"
	
		alt="https://hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222095134.png"
	
	
></p>
<h2 id="小结-5"><strong><code>小结</code></strong></h2>
<p>近些年<code>高速缓存</code>技术发展逐渐放缓，同时<code>缓存缺失</code>是导致<code>流水线停顿</code>的主要原因之一。由于<code>读取延迟</code>限制了<code>L1</code>缓存容量的提升，<code>L1</code>容量提高很少。半导体工艺发展放缓，晶体管数量增长速度降低以及功耗问题，也降低了<code>L2</code>、<code>L3</code>缓存容量增加的速度。同时高速缓存的引入也给<code>编译器</code>和<code>软件开发者</code>带来了更大的挑战，如何更好的利用<code>局部性原理</code>提高<code>缓存命中率</code>：开发者需要编写<code>缓存命中率</code>更高的代码、编译器需要生成<code>缓存命中率</code>更高的程序指令。</p>
<blockquote>
<p>提示：增加缓存容量的成本很高。以A17 Pro芯片为例，总共 190 亿个晶体管，因为包含GPU、NPU等协处理器，CPU使用的晶体管数量不超过 30%。缓存大小L2 20MB + L1 192KB，以一个缓存位需要几个晶体管来计算，缓存大概需要耗费几亿个晶体管。</p>
</blockquote>
<p>内存技术每一代新标准在增加<code>带宽</code>、<code>容量</code>和<code>能耗比</code>上都有不错的提升，但是<code>读取延迟</code>降低缓慢很多。内存读取延迟导致的<code>内存墙</code>依然是限制处理器性能的主要因素之一。因为<code>内存墙</code>的限制，现在也有一种<code>存算一体</code>的探索方向，将内存和计算单元集成在一起减少数据传输延迟。</p>
<p>现代处理器核心数越来越多，每个核心都有自己的<code>L1</code>缓存，多个核心需要共享<code>L2</code>缓存、<code>L3</code>缓存、内存数据。多核<code>缓存一致性</code>的复杂度越来越高，额外的开销可能会降低<code>读取延迟</code>和<code>增加功耗</code>，限制<code>多核</code>处理器的性能。</p>
<blockquote>
<p>提示：从高速缓存和内存上看，更小的程序体积、更小的内存占用是可以增加程序的运行性能的。</p>
</blockquote>
<h1 id="socdsa-和-chiplet"><strong><code>SOC、DSA 和 Chiplet</code></strong></h1>
<h2 id="soc"><strong><code>SOC</code></strong></h2>
<p><code>SOC</code>（System on Chip）片上系统是一种将多个不同模块封装在一个芯片中的技术。现代<code>CPU</code>基本上都属于<code>SOC</code>芯片，将<code>CPU</code>、<code>GPU</code>、<code>NPU</code>、<code>WIFI</code>、<code>蓝牙</code>、<code>Modem</code>等模块集成到同一个芯片中。由于半导体技术的发展可以集成在芯片上的晶体管数量越来越多，可以将更多的模块集成到一个芯片中带来<code>集成度</code>、<code>性能</code>、<code>系统单元复用率</code>的提升：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>模块</th>
<th>最新标准</th>
</tr>
</thead>
<tbody>
<tr>
<td>提高性能</td>
<td>不同模块集成在同一个芯片上，跨模块间通信更快、功耗更低。手机端SOC通常会将内存封装在SOC芯片上，不同模块可以使用统一内存的方式复用内存，降低内存在不同模块间的传输提高性能。</td>
</tr>
<tr>
<td>提高集成度</td>
<td>不同模块集成在同一个芯片上，相比传统多个模块芯片的设计可以复用重复的传输电路或内存等降低成本、降低面积、降低功耗。(例如传统CPU/GPU都有独立内存，封装到SOC中可以复用一个内存即可。)</td>
</tr>
</tbody>
</table></div>
<p>虽然带来了性能的优势，但是由于<code>SOC</code>集成了更多模块同时需要模块间互联，芯片设计、制造复杂度更高，导致成本也更高。</p>
<h3 id="soc-组成结构"><strong><code>SOC 组成结构</code></strong></h3>
<p>现代<code>SOC</code>通常由一个CPU单元、多个协处理器（NPU/GPU）、无线模块(WIFI/蓝牙/蜂窝网络)、多媒体单元（ISP、DSP）、内存控制器、I/O 单元组成：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>模块</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>CPU</td>
<td>中央处理器</td>
</tr>
<tr>
<td>GPU</td>
<td>图形渲染、高性能运算</td>
</tr>
<tr>
<td>NPU</td>
<td>神经网络运算、端测 AI 加速</td>
</tr>
<tr>
<td>ISP</td>
<td>相机传感器、拍照/视频图像信号处理、优化画面质量</td>
</tr>
<tr>
<td>DSP</td>
<td>音视频/图片硬件编解码</td>
</tr>
<tr>
<td>无线</td>
<td>WIFI、蓝牙、蜂窝网络的传输通讯、协议编解码、连接管理</td>
</tr>
<tr>
<td>Display Engine</td>
<td>管理屏幕显示、图像数据转换为屏幕格式、图像效果/分辨率优化、帧率调整</td>
</tr>
<tr>
<td>内存控制器</td>
<td>内存读写、内存地址映射、内存一致性、统一内存复用</td>
</tr>
<tr>
<td>I/O</td>
<td>管理输入/输出设备的 I/O 读写</td>
</tr>
</tbody>
</table></div>
<p>高通 8 gen 3</p>
<p><img src="/https:/hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222095209.png"
	
	
	
	loading="lazy"
	
		alt="https://hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222095209.png"
	
	
></p>
<ul>
<li><code>Hexagon Processor</code>AI 模块</li>
<li><code>FastConnect</code>WIFI、蓝牙</li>
</ul>
<p>Apple M3</p>
<p><img src="/https:/hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222095229.png"
	
	
	
	loading="lazy"
	
		alt="https://hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222095229.png"
	
	
></p>
<ul>
<li>从<code>M3</code>的设计上可以看出，现代<code>SOC</code>中<code>CPU</code>部分占用的硅面积不超过<code>30%</code></li>
</ul>
<h2 id="dsa"><strong><code>DSA</code></strong></h2>
<p><code>DSA</code>（Domain Specific Architecture）领域特定架构是一种用于特定领域计算的结算机体系。由于<code>CPU</code>是一种追求通用计算的计算机体系结构，对于特定领域计算（音视频、图形、AI 等）的性能和能效比都比较差。<code>DSA</code>通过面向特定领域计算的设计大幅提高性能和能耗比，解决<code>CPU</code>对于特定领域计算的性能劣势。</p>
<h3 id="dsa-设计"><strong><code>DSA 设计</code></strong></h3>
<p>现代<code>SOC</code>中的<code>GPU</code>、<code>NPU</code>、<code>DSP</code>就是一种常见的<code>DSA</code>模块。传统<code>CPU</code>通过复杂流水线设计、高速缓存、增加寄存器位数等特性提高<code>CPU</code>的运算性能，但是这会导致大量的晶体管消耗增加成本和能耗。<code>DSA</code>通过减少这些复杂的设计提高晶体管的利用率提高能效，相比<code>CPU</code>执行同样的特定领域运算可以带来的优势：更小的面积、更低的成本、更高的能耗比、更好的性能。</p>
<p>DSA 设计原则</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>特点</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>专用存储</td>
<td>使用专用存储器减少数据移动</td>
<td>-</td>
</tr>
<tr>
<td>最小化数据类型</td>
<td>使用更小位宽的数据类型来计算、节省存储空间、运算更快</td>
<td>-</td>
</tr>
<tr>
<td>更多运算单元或存储器</td>
<td>加入更多运算单元、更大的存储器</td>
<td>-</td>
</tr>
<tr>
<td>并行方式</td>
<td>选择更有利于特定领域计算的并行方式</td>
<td>例如 GPU 的并行方式</td>
</tr>
<tr>
<td>专用编程语言</td>
<td>使用面向特定领域计算的编程语言/框架进行编程</td>
<td>-</td>
</tr>
</tbody>
</table></div>
<h2 id="chiplet"><strong><code>Chiplet</code></strong></h2>
<p><code>Chiplet</code>是近几年发展出的一种将不同的功能模块分离成小芯片，并通过先进封装技术组合在一起的新技术。<code>Chiplet</code>主要是为了解决传统<code>SOC</code>遇到的<code>成本高</code>和<code>扩展性</code>问题。</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>特点</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>降低成本</td>
<td>不同芯片可以使用不同成本的工艺制造、小芯片可以复用降低设计成本、小芯片面积更小成本更低</td>
<td>-</td>
</tr>
<tr>
<td>灵活性、扩展性</td>
<td>根据诉求灵活集成不同的小芯片满足市场需求、3D 封装降低芯片面积</td>
<td>-</td>
</tr>
</tbody>
</table></div>
<p>不过<code>Chiplet</code>对封装技术的要求很好，不同小芯片间的通信设计也很复杂。目前只有少量的芯片使用了这种方式进行芯片制造。</p>
<p>Meteor Lake</p>
<p><img src="/https:/hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222095314.png"
	
	
	
	loading="lazy"
	
		alt="https://hjz-eva.oss-cn-beijing.aliyuncs.com/notion/20231222095314.png"
	
	
></p>
<ul>
<li><code>Intel</code>2023年推出的<code>Meteor Lake</code>处理器使用<code>Chiplet</code>封装，<code>CPU</code>使用Intel<code>4nm</code>工艺，<code>Graphics</code>使用台积电<code>5nm</code>工艺，<code>SOC</code>、<code>IO</code>使用台积电<code>6nm</code>工艺。</li>
</ul>
<h2 id="小结-6"><strong><code>小结</code></strong></h2>
<p>由于<code>CPU</code>通用处理器性能提升放缓和对特性领域计算的能耗比和成本问题，未来也许会加入更多的<code>DSA</code>模块用于提升特定领域计算的性能和能耗比。近些年<code>PC</code>端处理器也在效仿<code>移动端</code>处理器加强<code>DSA</code>单元能力，包括提高核显 GPU 的性能以及加入 NPU。同时<code>Chiplet</code>技术的发展也可以帮助处理器集成更多的<code>DSA</code>单元同时降低成本。</p>
<h1 id="主流-cpu-发展"><strong><code>主流 CPU 发展</code></strong></h1>
<h2 id="intel-处理器发展"><strong><code>Intel 处理器发展</code></strong></h2>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>核心数</th>
<th>线程数</th>
<th>指令集</th>
<th>微架构</th>
<th>工艺</th>
<th>晶体管数量</th>
<th>TDP</th>
<th>发行年份</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>Core i9-14900K</td>
<td>3.2 - 6 GHz</td>
<td>8 + 16</td>
<td>32</td>
<td>x86-64</td>
<td>Raptor Cove + Gracemont</td>
<td>7 nm</td>
<td>-</td>
<td>125 - 253W</td>
</tr>
<tr>
<td>Core i9-13900K</td>
<td>3 - 5.8 GHz</td>
<td>8 + 16</td>
<td>32</td>
<td>x86-64</td>
<td>Raptor Cove + Gracemont</td>
<td>7 nm</td>
<td>-</td>
<td>125 - 253W</td>
</tr>
<tr>
<td>Core i9-12900K</td>
<td>3.2 - 5.2 GHz</td>
<td>8 + 8</td>
<td>24</td>
<td>x86-64</td>
<td>Golden Cove + Gracemont</td>
<td>7 nm</td>
<td>-</td>
<td>125 - 241W</td>
</tr>
<tr>
<td>Core i9-11900K</td>
<td>3.5 - 5.3 GHz</td>
<td>8</td>
<td>16</td>
<td>x86-64</td>
<td>Cypress Cove 待确定</td>
<td>10 nm</td>
<td>-</td>
<td>95 - 125 W</td>
</tr>
<tr>
<td>Core i7-6700K</td>
<td>4 - 4.2 GHz</td>
<td>4</td>
<td>8</td>
<td>x86-64</td>
<td>Skylake</td>
<td>14 nm</td>
<td>-</td>
<td>91 W</td>
</tr>
<tr>
<td>Core i7-4790K</td>
<td>4 - 4.4 GHz</td>
<td>4</td>
<td>8</td>
<td>x86-64</td>
<td>Haswell</td>
<td>22 nm</td>
<td>-</td>
<td>88 W</td>
</tr>
<tr>
<td>Core i7-990X</td>
<td>3.4 - 3.7 GHz</td>
<td>6</td>
<td>12</td>
<td>x86-64</td>
<td>Westmere</td>
<td>32 nm</td>
<td>12 亿</td>
<td>130 W</td>
</tr>
<tr>
<td>Core 2 E6700</td>
<td>2.66 GHz</td>
<td>2</td>
<td>2</td>
<td>x86-64</td>
<td>Conroe</td>
<td>65 nm</td>
<td>2.9 亿</td>
<td>65 W</td>
</tr>
<tr>
<td>Pentium D Processor 840</td>
<td>3.2 GHz</td>
<td>2</td>
<td>2</td>
<td>x86-64</td>
<td>NetBurst</td>
<td>90 nm</td>
<td>2.3 亿</td>
<td>-</td>
</tr>
<tr>
<td>Pentium 4 Extreme Edition</td>
<td>3.4 GHz</td>
<td>1</td>
<td>2</td>
<td>x86-32</td>
<td>NetBurst</td>
<td>130 nm</td>
<td>-</td>
<td>110W</td>
</tr>
<tr>
<td>Pentium 4 2.8 GHz</td>
<td>2.8 GHz</td>
<td>1</td>
<td>1</td>
<td>x86-32</td>
<td>NetBurst</td>
<td>130 nm</td>
<td>5500 万</td>
<td>-</td>
</tr>
<tr>
<td>Pentium 3 Processor 1.1 GHz</td>
<td>1.1 GHz</td>
<td>1</td>
<td>1</td>
<td>x86-32</td>
<td>P6</td>
<td>180 nm</td>
<td>-</td>
<td>33 W</td>
</tr>
<tr>
<td>Pentium Pro 200 MHz</td>
<td>200 MHz</td>
<td>1</td>
<td>1</td>
<td>x86-32</td>
<td>P6</td>
<td>500 nm</td>
<td>550万</td>
<td>35W</td>
</tr>
<tr>
<td>Pentium</td>
<td>60 MHz</td>
<td>1</td>
<td>1</td>
<td>x86-32</td>
<td>P5</td>
<td>800 nm</td>
<td>310 万</td>
<td>-</td>
</tr>
<tr>
<td>80486</td>
<td>25 MHz</td>
<td>1</td>
<td>1</td>
<td>x86-32</td>
<td>i486</td>
<td>1 um</td>
<td>100万</td>
<td>-</td>
</tr>
<tr>
<td>80386</td>
<td>20 MHz</td>
<td>1</td>
<td>1</td>
<td>x86-32</td>
<td>-</td>
<td>1.5 um</td>
<td>27.5万</td>
<td>-</td>
</tr>
<tr>
<td>80286</td>
<td>12.5 MHz</td>
<td>1</td>
<td>1</td>
<td>x86-16</td>
<td>-</td>
<td>1.5 um</td>
<td>13.4 万</td>
<td>-</td>
</tr>
<tr>
<td>80186</td>
<td>6 MHz</td>
<td>1</td>
<td>1</td>
<td>x86-16</td>
<td>-</td>
<td>2 um</td>
<td>5.5 万</td>
<td>-</td>
</tr>
<tr>
<td>8086</td>
<td>5 MHz</td>
<td>1</td>
<td>1</td>
<td>x86-16</td>
<td>-</td>
<td>3 um</td>
<td>2.9 万</td>
<td>2 W</td>
</tr>
<tr>
<td>8085</td>
<td>3 MHz</td>
<td>1</td>
<td>1</td>
<td>8085</td>
<td>-</td>
<td>3 um</td>
<td>6500</td>
<td>-</td>
</tr>
<tr>
<td>8080</td>
<td>2 MHz</td>
<td>1</td>
<td>1</td>
<td>8080</td>
<td>-</td>
<td>6 um</td>
<td>4500</td>
<td>-</td>
</tr>
<tr>
<td>8008</td>
<td>0.5 MHz</td>
<td>1</td>
<td>1</td>
<td>8008</td>
<td>-</td>
<td>10 um</td>
<td>3500</td>
<td>1 - 2 W</td>
</tr>
</tbody>
</table></div>
<p><strong><strong>最新 CPU 微架构对比</strong></strong></p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>代号</th>
<th>类型</th>
<th>指令集</th>
<th>线程数</th>
<th>解码宽度</th>
<th>ROB</th>
<th>发射宽度</th>
<th>分支预测惩罚</th>
<th>L1 缓存</th>
<th>L2 缓存</th>
<th>SIMD</th>
<th>IPC</th>
</tr>
</thead>
<tbody>
<tr>
<td>Raptor Cove</td>
<td>Intel 性能核</td>
<td>x86-64</td>
<td>2（超线程）</td>
<td>6</td>
<td>512</td>
<td>6</td>
<td>8</td>
<td>48 KB（D）、32 KB（I）</td>
<td>2 MB</td>
<td>AVX 512</td>
<td>3.525、4.23（超线程）</td>
</tr>
<tr>
<td>Gracemont</td>
<td>Intel 能效核</td>
<td>x86-64</td>
<td>1</td>
<td>6</td>
<td>256</td>
<td>6</td>
<td>8</td>
<td>32 KB（D）、64 KB（I）</td>
<td>2 MB(共享)</td>
<td>AVX 256</td>
<td>2.52</td>
</tr>
<tr>
<td>A520</td>
<td>ARM 小核</td>
<td>ARMv9</td>
<td>1</td>
<td>3</td>
<td>0</td>
<td>3</td>
<td>-</td>
<td>64 KB（D）、32 KB（I）</td>
<td>256 KB</td>
<td>SVE</td>
<td>0.94</td>
</tr>
<tr>
<td>A720</td>
<td>ARM 大核</td>
<td>ARMv9</td>
<td>1</td>
<td>5</td>
<td>192</td>
<td>5</td>
<td>-</td>
<td>64 KB（D）、32 KB（I）</td>
<td>512 KB</td>
<td>SVE</td>
<td>3.03</td>
</tr>
<tr>
<td>X4</td>
<td>ARM 超大核</td>
<td>ARMv9</td>
<td>1</td>
<td>10</td>
<td>384</td>
<td>10</td>
<td>-</td>
<td>64 KB（D）、64 KB（I）</td>
<td>2 MB</td>
<td>SVE</td>
<td>4.4</td>
</tr>
<tr>
<td>A17 E</td>
<td>Apple 能效核</td>
<td>ARMv8</td>
<td>1</td>
<td>5</td>
<td>224</td>
<td>5</td>
<td>5</td>
<td>128 KB（D） + 64 KB（I）</td>
<td>4 MB（共享）</td>
<td>NEON</td>
<td>3.05</td>
</tr>
<tr>
<td>A17 P</td>
<td>Apple 性能核</td>
<td>ARMv8</td>
<td>1</td>
<td>9</td>
<td>670</td>
<td>9</td>
<td>9</td>
<td>64 KB（D）、128 KB（I）</td>
<td>16 MB（共享）</td>
<td>NEON</td>
<td>5.06</td>
</tr>
</tbody>
</table></div>
<h1 id="对开发者的影响"><strong><code>对开发者的影响</code></strong></h1>
<h2 id="更多核心数"><strong><code>更多核心数</code></strong></h2>
<p><code>CPU</code>核心数越来越多，软件开发者需要使用面向多线程的利用更多的核心并行才能提高程序执行的性能。同时也可以导致编程语言、编程范式、框架的一些改变：</p>
<ul>
<li><code>多线程编程</code>更多的使用到多线程编程利用多核的性能</li>
<li><code>简化并行编程</code>编程语言提供了更多特性简化并行编程，例如<code>async/await</code>函数、结构化并发</li>
<li><code>异步编程</code>更多的跨线程异步调用</li>
<li><code>非共享内存的并发模型</code>可以减少数据竞争、减少线程锁使用、减少线程切换的耗时，<code>Go</code>、<code>Rust</code>、<code>Swift</code>语言都提供了类似的并发模型</li>
<li><code>UI框架</code>传统<code>UI</code>框架都是基于单线程模型设计，<code>UI</code>框架和<code>浏览器</code>需要更好的利用多核心的性能优势。同时非<code>UI</code>操作需要更多考虑多线程的利用减少主线程的消耗</li>
<li><code>函数式编程</code>函数式编程更有利于并行执行变得更流行</li>
</ul>
<h2 id="simddsa单元"><strong><code>SIMD、DSA单元</code></strong></h2>
<p><code>SOC</code>不断增加更多的<code>DSA</code>单元增加特定领域运算的能耗比，未来可能需要面向更多不同类型的处理器进行编程，不同的处理器会导致编程语言和编程范式的改变。</p>
<h2 id="硬件性能提升放缓"><strong><code>硬件性能提升放缓</code></strong></h2>
<p><code>CPU</code>性能提升放缓带给软件的性能提升更少，同时软件自身功能不断增加对于性能的消耗，软件追求更高的性能提升就需要做更多的软件性能优化。</p>
<ul>
<li><code>AOT</code>类似<code>Java</code>、<code>C#</code>、<code>JS</code>这些传统的解释执行编程语言开始追求<code>AOT</code>编译提高性能，新的编程语言通常也会支持<code>AOT</code>编译</li>
<li><code>简化内存管理</code>简化传统的自动内存管理方式，使用更简单的内存管理方式。例如<code>Rust</code>的所有权更多利用编译器去检查内存安全</li>
<li><code>值类型</code>更多的值类型使用，栈上的值类型性能更好</li>
<li><code>编译器</code>编译器利用静态优化生成性能更好的代码减少运行时消耗，静态类型系统、静态方法派发</li>
</ul>
<h1 id="相关链接"><strong>相关链接</strong></h1>
<ul>
<li><a class="link" href="https://book.douban.com/subject/36490912/"  target="_blank" rel="noopener"
    >计算机组成与设计：硬件/软件接口 RISC-V版（原书第2版）</a></li>
<li><a class="link" href="https://book.douban.com/subject/36108789/"  target="_blank" rel="noopener"
    >计算机体系结构：量化研究方法（第6版）</a></li>
<li><a class="link" href="https://book.douban.com/subject/35803160/"  target="_blank" rel="noopener"
    >ARM64体系结构编程与实践</a></li>
<li><a class="link" href="https://book.douban.com/subject/36350632/"  target="_blank" rel="noopener"
    >芯片战争</a></li>
<li><a class="link" href="https://book.douban.com/subject/36357053/"  target="_blank" rel="noopener"
    >芯片简史</a></li>
<li><a class="link" href="https://developer.arm.com/documentation/102404/0201"  target="_blank" rel="noopener"
    >Introducing the Arm architecture</a></li>
<li><a class="link" href="https://developer.arm.com/Architectures/A-Profile%20Architecture"  target="_blank" rel="noopener"
    >Arm A-Profile Architecture</a></li>
<li><a class="link" href="https://developer.arm.com/documentation/102374/0101"  target="_blank" rel="noopener"
    >Arm A64 Instruction Set Architecture</a></li>
<li><a class="link" href="https://developer.arm.com/documentation/ddi0602/2023-09/Base-Instructions?lang=en"  target="_blank" rel="noopener"
    >Arm A-profile A64 Instruction Set Architecture</a></li>
<li><a class="link" href="https://developer.arm.com/documentation/101811/latest"  target="_blank" rel="noopener"
    >AArch64 memory management</a></li>
<li><a class="link" href="https://www.qualcomm.com/products/mobile/snapdragon/smartphones/snapdragon-8-series-mobile-platforms/snapdragon-8-gen-3-mobile-platform"  target="_blank" rel="noopener"
    >Snapdragon 8 Gen 3 Mobile Platform</a></li>
<li><a class="link" href="https://www.qualcomm.com/products/mobile/snapdragon/pcs-and-tablets/snapdragon-x-elite"  target="_blank" rel="noopener"
    >Snapdragon X Elite</a></li>
<li><a class="link" href="https://nanoreview.net/"  target="_blank" rel="noopener"
    >NanoReview</a></li>
<li><a class="link" href="https://browser.geekbench.com/"  target="_blank" rel="noopener"
    >Geekbench</a></li>
<li><a class="link" href="https://www.intel.cn/content/www/cn/zh/products/sku/236773/intel-core-i9-processor-14900k-36m-cache-up-to-6-00-ghz/specifications.html"  target="_blank" rel="noopener"
    >Intel Core i9-14900K</a></li>
<li><a class="link" href="https://www.intel.cn/content/www/cn/zh/products/sku/199332/intel-core-i910900k-processor-20m-cache-up-to-5-30-ghz/specifications.html"  target="_blank" rel="noopener"
    >Intel Core i9-10900K</a></li>
<li><a class="link" href="https://ark.intel.com/content/www/cn/zh/ark/products/27251/intel-core2-duo-processor-e6700-4m-cache-2-66-ghz-1066-mhz-fsb.html"  target="_blank" rel="noopener"
    >Intel Core 2 E6700</a></li>
<li><a class="link" href="https://ark.intel.com/content/www/us/en/ark/products/27491/pentium-4-processor-extreme-edition-supporting-ht-technology-3-46-ghz-2m-cache-1066-mhz-fsb.html"  target="_blank" rel="noopener"
    >Pentium 4 Processor Extreme Edition</a></li>
<li><a class="link" href="https://www.intel.cn/content/www/cn/zh/products/sku/27530/intel-pentium-iii-processor-1-10-ghz-256k-cache-100-mhz-fsb/specifications.html"  target="_blank" rel="noopener"
    >Intel Pentium III Processor 1.1 GHz</a></li>
<li><a class="link" href="https://www.intel.cn/content/www/cn/zh/products/sku/49951/intel-pentium-pro-processor-200-mhz-1m-cache-66-mhz-fsb/specifications.html?wapkw=Pentium%20Pro"  target="_blank" rel="noopener"
    >Intel Pentium Pro 200 MHz</a></li>
<li><a class="link" href="https://en.wikipedia.org/wiki/Intel_80486"  target="_blank" rel="noopener"
    >80486</a></li>
<li><a class="link" href="https://en.wikipedia.org/wiki/Intel_80386"  target="_blank" rel="noopener"
    >80386</a></li>
<li><a class="link" href="https://en.wikipedia.org/wiki/Intel_80286"  target="_blank" rel="noopener"
    >80286</a></li>
<li><a class="link" href="https://en.wikipedia.org/wiki/Intel_80186"  target="_blank" rel="noopener"
    >80186</a></li>
<li><a class="link" href="https://en.wikipedia.org/wiki/Intel_8086"  target="_blank" rel="noopener"
    >8086</a></li>
<li><a class="link" href="https://en.wikipedia.org/wiki/List_of_Intel_processors"  target="_blank" rel="noopener"
    >Intel Processors</a></li>
<li><a class="link" href="https://drive.google.com/drive/folders/1W4CIRKtNML74BKjSbXerRsIzAUk3ppSG?usp=sharing"  target="_blank" rel="noopener"
    >CPU 微架构设计</a></li>
</ul>

</section>


    <footer class="article-footer">
    

    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
</article>

    

    

     
    
        
    <div class="disqus-container">
    <div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hugo-theme-stack" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<style>
    .disqus-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
</style>

<script>
    window.addEventListener('onColorSchemeChange', (e) => {
        if (typeof DISQUS == 'object') {
            DISQUS.reset({
                reload: true
            });
        }
    })
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2024 hello
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.21.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
